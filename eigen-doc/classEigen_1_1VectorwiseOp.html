<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: Eigen::VectorwiseOp&lt; ExpressionType, Direction &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<!--
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better know about our user community by answering the following short survey:  <a href="https://forms.gle/wpyrxWi18ox9Z5ae9">https://forms.gle/wpyrxWi18ox9Z5ae9</a></div>
-->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.4.0 (git rev e3e74001f7c4bf95f0dde572e8a08c5b2918a3ab)</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classEigen_1_1VectorwiseOp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classEigen_1_1VectorwiseOp-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::VectorwiseOp&lt; ExpressionType, Direction &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__DenseMatrixManipulation__chapter.html">稠密矩阵和数组的操作</a> &raquo; <a class="el" href="group__DenseMatrixManipulation__Reference.html">Reference</a> &raquo; <a class="el" href="group__Core__Module.html">Core module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ExpressionType, int Direction&gt;<br />
class Eigen::VectorwiseOp&lt; ExpressionType, Direction &gt;</h3>

<p>Pseudo expression providing broadcasting and partial reduction operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>the type of the object on which to do partial reductions </td></tr>
    <tr><td class="paramname">Direction</td><td>indicates whether to operate on columns (<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7ae2efac6e74ecab5e3b0b1561c5ddf83e">Vertical</a>) or rows (<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7a961c62410157b64033839488f4d7f7e4">Horizontal</a>)</td></tr>
  </table>
  </dd>
</dl>
<p>This class represents a pseudo expression with broadcasting and partial reduction features. It is the return type of <a class="el" href="classEigen_1_1DenseBase.html#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a> and <a class="el" href="classEigen_1_1DenseBase.html#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a> and most of the time this is the only way it is explicitly used.</p>
<p>To understand the logic of rowwise/colwise expression, let's consider a generic case <code>A.colwise().foo()</code> where <code>foo</code> is any method of <code><a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a></code>. This expression is equivalent to applying <code>foo()</code> to each column of <code>A</code> and then re-assemble the outputs in a matrix expression: </p><div class="fragment"><div class="line">[A.col(0).foo(), A.col(1).foo(), ..., A.col(A.cols()-1).foo()] </div>
</div><!-- fragment --><p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().sum() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum absolute value of each column:&quot;</span></div>
<div class="line">     &lt;&lt; endl &lt;&lt; m.cwiseAbs().colwise().maxCoeff() &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_ae814abb451b48ed872819192dc188c19"><div class="ttname"><a href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Eigen::DenseBase::Random</a></div><div class="ttdeci">static const RandomReturnType Random()</div><div class="ttdef"><b>Definition:</b> Random.h:113</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the sum of each column:
  1.04  0.815 -0.238
Here is the maximum absolute value of each column:
 0.68 0.823 0.536
</pre><p>The <a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a> and <a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end()</a> methods are obviously exceptions to the previous rule as they return STL-compatible begin/end iterators to the rows or columns of the nested expression. Typical use cases include for-range-loop and calls to STL algorithms:</p>
<p>Example: </p><div class="fragment"><div class="line">Matrix3i m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the initial matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line"><span class="keywordtype">int</span> i = -1;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> c: m.colwise()) {</div>
<div class="line">  c *= i;</div>
<div class="line">  ++i;</div>
<div class="line">}</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m after the for-range-loop:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line"><span class="keyword">auto</span> cols = m.colwise();</div>
<div class="line"><span class="keyword">auto</span> it = std::find_if(cols.cbegin(), cols.cend(),</div>
<div class="line">                       [](Matrix3i::ConstColXpr x) { return x.squaredNorm() == 0; });</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;The first empty column is: &quot;</span> &lt;&lt; distance(cols.cbegin(),it) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the initial matrix m:
 7  6 -3
-2  9  6
 6 -6 -5
Here is the matrix m after the for-range-loop:
-7  0 -3
 2  0  6
-6  0 -5
The first empty column is: 1
</pre><p>For a partial reduction on an empty input, some rules apply. For the sake of clarity, let's consider a vertical reduction:</p><ul>
<li>If the number of columns is zero, then a 1x0 row-major vector expression is returned.</li>
<li>Otherwise, if the number of rows is zero, then<ul>
<li>a row vector of zeros is returned for sum-like reductions (sum, squaredNorm, norm, etc.)</li>
<li>a row vector of ones is returned for a product reduction (e.g., <code>MatrixXd(n,0).colwise().<a class="el" href="classEigen_1_1VectorwiseOp.html#a01bcd17504f30b55b4910ddb75598f79">prod()</a></code>)</li>
<li>an assert is triggered for all other reductions (minCoeff,maxCoeff,redux(bin_op))</li>
</ul>
</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a>, class <a class="el" href="classEigen_1_1PartialReduxExpr.html" title="Generic expression of a partially reduxed matrix.">PartialReduxExpr</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4907c654e5810edd98e4162093b19532"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a></td></tr>
<tr class="separator:a4907c654e5810edd98e4162093b19532"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9c2b4740bf190492bf231d8e244b25c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AllReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9c2b4740bf190492bf231d8e244b25c1">all</a> () const</td></tr>
<tr class="separator:a9c2b4740bf190492bf231d8e244b25c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96210c9f83bd375f8ce862bd62ab70e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AnyReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a96210c9f83bd375f8ce862bd62ab70e6">any</a> () const</td></tr>
<tr class="separator:a96210c9f83bd375f8ce862bd62ab70e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf3325f535ac011ed61f14ed4330618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin</a> ()</td></tr>
<tr class="separator:abbf3325f535ac011ed61f14ed4330618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf91f2a57a26e88e7131fcd9c194f93f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aaf91f2a57a26e88e7131fcd9c194f93f">begin</a> () const</td></tr>
<tr class="separator:aaf91f2a57a26e88e7131fcd9c194f93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2fbc5296470a94379cbcb33bb9c24d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">BlueNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4d2fbc5296470a94379cbcb33bb9c24d">blueNorm</a> () const</td></tr>
<tr class="separator:a4d2fbc5296470a94379cbcb33bb9c24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b237a2b46479de5c905d2bcc54f34c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a7b237a2b46479de5c905d2bcc54f34c4">cbegin</a> () const</td></tr>
<tr class="separator:a7b237a2b46479de5c905d2bcc54f34c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57859b88a32b8b393a427c4cab3581a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a57859b88a32b8b393a427c4cab3581a7">cend</a> () const</td></tr>
<tr class="separator:a57859b88a32b8b393a427c4cab3581a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6b797457895f11a7682b3a16f263bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">CountReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a5c6b797457895f11a7682b3a16f263bb">count</a> () const</td></tr>
<tr class="separator:a5c6b797457895f11a7682b3a16f263bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec95725eed4adb5ccf65fbb6e907d12e"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aec95725eed4adb5ccf65fbb6e907d12e">crbegin</a> () const</td></tr>
<tr class="separator:aec95725eed4adb5ccf65fbb6e907d12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fa202916349d11e476f459543395ef"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a23fa202916349d11e476f459543395ef">crend</a> () const</td></tr>
<tr class="separator:a23fa202916349d11e476f459543395ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe1a2a012ce0ab0e8da6af134073039"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ga2fe1a2a012ce0ab0e8da6af134073039"><td class="memTemplItemLeft" align="right" valign="top">const CrossReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#ga2fe1a2a012ce0ab0e8da6af134073039">cross</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:ga2fe1a2a012ce0ab0e8da6af134073039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d189042b8322e40772d41c63b9d3bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end</a> ()</td></tr>
<tr class="separator:a9d189042b8322e40772d41c63b9d3bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b0dcb34bb4903ffa1ab3634188ecff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ad3b0dcb34bb4903ffa1ab3634188ecff">end</a> () const</td></tr>
<tr class="separator:ad3b0dcb34bb4903ffa1ab3634188ecff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f220045efa302626c287088b63b6ba9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">HNormalizedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#ga1f220045efa302626c287088b63b6ba9">hnormalized</a> () const</td></tr>
<tr class="memdesc:ga1f220045efa302626c287088b63b6ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">column or row-wise homogeneous normalization  <a href="group__Geometry__Module.html#ga1f220045efa302626c287088b63b6ba9">More...</a><br /></td></tr>
<tr class="separator:ga1f220045efa302626c287088b63b6ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf99305a3d7432318236df7b80022df37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Homogeneous.html">HomogeneousReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#gaf99305a3d7432318236df7b80022df37">homogeneous</a> () const</td></tr>
<tr class="separator:gaf99305a3d7432318236df7b80022df37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c44e033eec33586ae8093a6366da75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">HypotNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a00c44e033eec33586ae8093a6366da75">hypotNorm</a> () const</td></tr>
<tr class="separator:a00c44e033eec33586ae8093a6366da75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c2cad38085e7f5f9bc2598eff249f1"><td class="memTemplParams" colspan="2">template&lt;int p&gt; </td></tr>
<tr class="memitem:aa9c2cad38085e7f5f9bc2598eff249f1"><td class="memTemplItemLeft" align="right" valign="top">const LpNormReturnType&lt; p &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aa9c2cad38085e7f5f9bc2598eff249f1">lpNorm</a> () const</td></tr>
<tr class="separator:aa9c2cad38085e7f5f9bc2598eff249f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6646b584db116c1661b5bb56750bd6f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MaxCoeffReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a6646b584db116c1661b5bb56750bd6f6">maxCoeff</a> () const</td></tr>
<tr class="separator:a6646b584db116c1661b5bb56750bd6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7d867f9e6b74a1bc7f108d646cfa85"><td class="memItemLeft" align="right" valign="top">const MeanReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aaf7d867f9e6b74a1bc7f108d646cfa85">mean</a> () const</td></tr>
<tr class="separator:aaf7d867f9e6b74a1bc7f108d646cfa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7b8c03d180b126fde0ac212e2b0b76"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MinCoeffReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a7d7b8c03d180b126fde0ac212e2b0b76">minCoeff</a> () const</td></tr>
<tr class="separator:a7d7b8c03d180b126fde0ac212e2b0b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af726d1dfd9a7a67b76e639db1a9f352e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">NormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#af726d1dfd9a7a67b76e639db1a9f352e">norm</a> () const</td></tr>
<tr class="separator:af726d1dfd9a7a67b76e639db1a9f352e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1084153780dc8d2c062fee97651a45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#adb1084153780dc8d2c062fee97651a45">normalize</a> ()</td></tr>
<tr class="separator:adb1084153780dc8d2c062fee97651a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6ac44a9bf819d5d64c2cb54bf38095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename OppositeExtendedType&lt; <a class="el" href="classEigen_1_1CwiseUnaryOp.html">NormReturnType</a> &gt;::Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aca6ac44a9bf819d5d64c2cb54bf38095">normalized</a> () const</td></tr>
<tr class="separator:aca6ac44a9bf819d5d64c2cb54bf38095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ca4c1e409897feca669dee811533c9"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a25ca4c1e409897feca669dee811533c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a25ca4c1e409897feca669dee811533c9">operator*</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a25ca4c1e409897feca669dee811533c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef518a77a8947c6726ba30d56dd67cb"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:acef518a77a8947c6726ba30d56dd67cb"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#acef518a77a8947c6726ba30d56dd67cb">operator*=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:acef518a77a8947c6726ba30d56dd67cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713694459d81b76e4f2a78e4d169f8d6"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a713694459d81b76e4f2a78e4d169f8d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_sum_op&lt; Scalar, typename OtherDerived::Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a713694459d81b76e4f2a78e4d169f8d6">operator+</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a713694459d81b76e4f2a78e4d169f8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ce2522d11c3362ca22252b2876812b"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a23ce2522d11c3362ca22252b2876812b"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a23ce2522d11c3362ca22252b2876812b">operator+=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a23ce2522d11c3362ca22252b2876812b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e60616620df132d665b301bb9a304c4"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a5e60616620df132d665b301bb9a304c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_difference_op&lt; Scalar, typename OtherDerived::Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a5e60616620df132d665b301bb9a304c4">operator-</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a5e60616620df132d665b301bb9a304c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb3a7315617f86f0c28ac05816cf6e3"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a6bb3a7315617f86f0c28ac05816cf6e3"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a6bb3a7315617f86f0c28ac05816cf6e3">operator-=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a6bb3a7315617f86f0c28ac05816cf6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa154a8407885a9ad51504180f6d7a163"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:aa154a8407885a9ad51504180f6d7a163"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aa154a8407885a9ad51504180f6d7a163">operator/</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:aa154a8407885a9ad51504180f6d7a163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efa0b81915c31535a929a46a79cab2b"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a9efa0b81915c31535a929a46a79cab2b"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9efa0b81915c31535a929a46a79cab2b">operator/=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a9efa0b81915c31535a929a46a79cab2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7999eb8f50bb19ade54f3212d3c79680"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a7999eb8f50bb19ade54f3212d3c79680"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a7999eb8f50bb19ade54f3212d3c79680">operator=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a7999eb8f50bb19ade54f3212d3c79680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bcd17504f30b55b4910ddb75598f79"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">ProdReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a01bcd17504f30b55b4910ddb75598f79">prod</a> () const</td></tr>
<tr class="separator:a01bcd17504f30b55b4910ddb75598f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a8087eb76e210b07192c81d362dd1e"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a91a8087eb76e210b07192c81d362dd1e">rbegin</a> ()</td></tr>
<tr class="separator:a91a8087eb76e210b07192c81d362dd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e8a0230fcc049346057ef1a6efe02"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aa73e8a0230fcc049346057ef1a6efe02">rbegin</a> () const</td></tr>
<tr class="separator:aa73e8a0230fcc049346057ef1a6efe02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92babb33ed5a91eb0c4de80a97eafca"><td class="memTemplParams" colspan="2">template&lt;typename BinaryOp &gt; </td></tr>
<tr class="memitem:ae92babb33ed5a91eb0c4de80a97eafca"><td class="memTemplItemLeft" align="right" valign="top">const ReduxReturnType&lt; BinaryOp &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ae92babb33ed5a91eb0c4de80a97eafca">redux</a> (const BinaryOp &amp;func=BinaryOp()) const</td></tr>
<tr class="separator:ae92babb33ed5a91eb0c4de80a97eafca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9592e93b704f7712e8f33631a2efe8f"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aa9592e93b704f7712e8f33631a2efe8f">rend</a> ()</td></tr>
<tr class="separator:aa9592e93b704f7712e8f33631a2efe8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb3e3ceca37ae0a6e313f80743f767a"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#afeb3e3ceca37ae0a6e313f80743f767a">rend</a> () const</td></tr>
<tr class="separator:afeb3e3ceca37ae0a6e313f80743f767a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0c8dc9e9c4aeaa2057f15800f5c18c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">ReplicateReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a5f0c8dc9e9c4aeaa2057f15800f5c18c">replicate</a> (<a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a> factor) const</td></tr>
<tr class="separator:a5f0c8dc9e9c4aeaa2057f15800f5c18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bfb88fe6415c7bfd9bdf15ef608aaa"><td class="memTemplParams" colspan="2">template&lt;int Factor&gt; </td></tr>
<tr class="memitem:a81bfb88fe6415c7bfd9bdf15ef608aaa"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; ExpressionType, isVertical *Factor+isHorizontal, isHorizontal *Factor+isVertical &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a81bfb88fe6415c7bfd9bdf15ef608aaa">replicate</a> (<a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a> factor=Factor) const</td></tr>
<tr class="separator:a81bfb88fe6415c7bfd9bdf15ef608aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8caf5367e2bd636536c8a0e0c89fe15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ab8caf5367e2bd636536c8a0e0c89fe15">reverse</a> ()</td></tr>
<tr class="separator:ab8caf5367e2bd636536c8a0e0c89fe15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0428f561b5757e2c85e8d72022eec1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aeb0428f561b5757e2c85e8d72022eec1">reverse</a> () const</td></tr>
<tr class="separator:aeb0428f561b5757e2c85e8d72022eec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dd7c273eb2ba8defaab2d55156936b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ab9dd7c273eb2ba8defaab2d55156936b">reverseInPlace</a> ()</td></tr>
<tr class="separator:ab9dd7c273eb2ba8defaab2d55156936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01474cf971473a73c919f6a99323d4f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SquaredNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a01474cf971473a73c919f6a99323d4f5">squaredNorm</a> () const</td></tr>
<tr class="separator:a01474cf971473a73c919f6a99323d4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add48fd836be98ed280cac23518db0916"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">StableNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#add48fd836be98ed280cac23518db0916">stableNorm</a> () const</td></tr>
<tr class="separator:add48fd836be98ed280cac23518db0916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7030fc687c24d687ed7cd70733ba611c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SumReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a7030fc687c24d687ed7cd70733ba611c">sum</a> () const</td></tr>
<tr class="separator:a7030fc687c24d687ed7cd70733ba611c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a595c33d2a82427a1159568b0b8438554"><td class="memItemLeft" align="right" valign="top">random_access_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a></td></tr>
<tr class="separator:a595c33d2a82427a1159568b0b8438554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb8aaf24528efcdac1782aacf99b8dd"><td class="memItemLeft" align="right" valign="top">random_access_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a></td></tr>
<tr class="separator:a9fb8aaf24528efcdac1782aacf99b8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4907c654e5810edd98e4162093b19532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4907c654e5810edd98e4162093b19532">&#9670;&nbsp;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::<a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>since <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9c2b4740bf190492bf231d8e244b25c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2b4740bf190492bf231d8e244b25c1">&#9670;&nbsp;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AllReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing whether <b>all</b> coefficients of each respective column (or row) are <code>true</code>. This expression can be assigned to a vector with entries of type <code>bool</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ae42ab60296c120e9f45ce3b44e1761a4">DenseBase::all()</a> </dd></dl>

</div>
</div>
<a id="a96210c9f83bd375f8ce862bd62ab70e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96210c9f83bd375f8ce862bd62ab70e6">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AnyReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing whether <b>at</b> <b>least</b> one coefficient of each respective column (or row) is <code>true</code>. This expression can be assigned to a vector with entries of type <code>bool</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#abfbf4cb72dd577e62fbe035b1c53e695">DenseBase::any()</a> </dd></dl>

</div>
</div>
<a id="abbf3325f535ac011ed61f14ed4330618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf3325f535ac011ed61f14ed4330618">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns an iterator to the first row (rowwise) or column (colwise) of the nested expression. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#a7b237a2b46479de5c905d2bcc54f34c4">cbegin()</a> </dd></dl>

</div>
</div>
<a id="aaf91f2a57a26e88e7131fcd9c194f93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf91f2a57a26e88e7131fcd9c194f93f">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a> </p>

</div>
</div>
<a id="a4d2fbc5296470a94379cbcb33bb9c24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2fbc5296470a94379cbcb33bb9c24d">&#9670;&nbsp;</a></span>blueNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">BlueNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::blueNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, using Blue's algorithm. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::blueNorm() </dd></dl>

</div>
</div>
<a id="a7b237a2b46479de5c905d2bcc54f34c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b237a2b46479de5c905d2bcc54f34c4">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a> </p>

</div>
</div>
<a id="a57859b88a32b8b393a427c4cab3581a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57859b88a32b8b393a427c4cab3581a7">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end()</a> </p>

</div>
</div>
<a id="a5c6b797457895f11a7682b3a16f263bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6b797457895f11a7682b3a16f263bb">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">CountReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing the number of <code>true</code> coefficients of each respective column (or row). This expression can be assigned to a vector whose entries have the same type as is used to index entries of the original matrix; for dense matrices, this is <code>std::ptrdiff_t</code> .</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">Matrix&lt;ptrdiff_t, 3, 1&gt; res = (m.array() &gt;= 0.5).rowwise().count();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the count of elements larger or equal than 0.5 of each row:&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; res &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the count of elements larger or equal than 0.5 of each row:
2
2
1
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a229be090c665b9bf7d1fcdfd1ab6e0c1">DenseBase::count()</a> </dd></dl>

</div>
</div>
<a id="aec95725eed4adb5ccf65fbb6e907d12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec95725eed4adb5ccf65fbb6e907d12e">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#a91a8087eb76e210b07192c81d362dd1e">rbegin()</a> </p>

</div>
</div>
<a id="a23fa202916349d11e476f459543395ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fa202916349d11e476f459543395ef">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#aa9592e93b704f7712e8f33631a2efe8f">rend()</a> </p>

</div>
</div>
<a id="a9d189042b8322e40772d41c63b9d3bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d189042b8322e40772d41c63b9d3bb5">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns an iterator to the row (resp. column) following the last row (resp. column) of the nested expression </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#a57859b88a32b8b393a427c4cab3581a7">cend()</a> </dd></dl>

</div>
</div>
<a id="ad3b0dcb34bb4903ffa1ab3634188ecff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b0dcb34bb4903ffa1ab3634188ecff">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end()</a> </p>

</div>
</div>
<a id="a00c44e033eec33586ae8093a6366da75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c44e033eec33586ae8093a6366da75">&#9670;&nbsp;</a></span>hypotNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">HypotNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::hypotNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, avoiding underflow and overflow using a concatenation of hypot() calls. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::hypotNorm() </dd></dl>

</div>
</div>
<a id="aa9c2cad38085e7f5f9bc2598eff249f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c2cad38085e7f5f9bc2598eff249f1">&#9670;&nbsp;</a></span>lpNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;int p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const LpNormReturnType&lt;p&gt;::Type <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::lpNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the norm of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().norm() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the norm of each column:
 0.91  1.18 0.771
</pre><dl class="section see"><dt>See also</dt><dd>DenseBase::norm() </dd></dl>

</div>
</div>
<a id="a6646b584db116c1661b5bb56750bd6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6646b584db116c1661b5bb56750bd6f6">&#9670;&nbsp;</a></span>maxCoeff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MaxCoeffReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::maxCoeff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the largest coefficient of each column (or row) of the referenced expression.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the size along the reduction direction must be strictly positive, otherwise an assertion is triggered.</dd>
<dd>
the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().maxCoeff() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the maximum of each column:
 0.68 0.823 0.536
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a7e6987d106f1cca3ac6ab36d288cc8e1">DenseBase::maxCoeff()</a> </dd></dl>

</div>
</div>
<a id="aaf7d867f9e6b74a1bc7f108d646cfa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7d867f9e6b74a1bc7f108d646cfa85">&#9670;&nbsp;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MeanReturnType <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the mean of each column (or row) of the referenced expression.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a21ac6c0419a72ad7a88ea0bc189017d7">DenseBase::mean()</a> </dd></dl>

</div>
</div>
<a id="a7d7b8c03d180b126fde0ac212e2b0b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7b8c03d180b126fde0ac212e2b0b76">&#9670;&nbsp;</a></span>minCoeff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MinCoeffReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::minCoeff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the smallest coefficient of each column (or row) of the referenced expression.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the size along the reduction direction must be strictly positive, otherwise an assertion is triggered.</dd>
<dd>
the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the minimum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().minCoeff() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the minimum of each column:
-0.211 -0.605 -0.444
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a0739f9c868c331031c7810e21838dcb2">DenseBase::minCoeff()</a> </dd></dl>

</div>
</div>
<a id="af726d1dfd9a7a67b76e639db1a9f352e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af726d1dfd9a7a67b76e639db1a9f352e">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">NormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the norm of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().norm() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the norm of each column:
 0.91  1.18 0.771
</pre><dl class="section see"><dt>See also</dt><dd>DenseBase::norm() </dd></dl>

</div>
</div>
<a id="adb1084153780dc8d2c062fee97651a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1084153780dc8d2c062fee97651a45">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalize in-place each row or columns of the referenced matrix. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ad16303c47ba36f7a41ea264cb26bceb6">MatrixBase::normalize()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#aca6ac44a9bf819d5d64c2cb54bf38095">normalized()</a> </dd></dl>

</div>
</div>
<a id="aca6ac44a9bf819d5d64c2cb54bf38095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6ac44a9bf819d5d64c2cb54bf38095">&#9670;&nbsp;</a></span>normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;Scalar&gt;, const ExpressionTypeNestedCleaned, const typename OppositeExtendedType&lt;<a class="el" href="classEigen_1_1CwiseUnaryOp.html">NormReturnType</a>&gt;::Type&gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::normalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression where each column (or row) of the referenced matrix are normalized. The referenced matrix is <b>not</b> modified. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a5cf2fd4c57e59604fd4116158fd34308">MatrixBase::normalized()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#adb1084153780dc8d2c062fee97651a45">normalize()</a> </dd></dl>

</div>
</div>
<a id="a25ca4c1e409897feca669dee811533c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ca4c1e409897feca669dee811533c9">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_product_op&lt;Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression where each subvector is the product of the vector <em>other</em> by the corresponding subvector of <code>*this</code> </p>

</div>
</div>
<a id="acef518a77a8947c6726ba30d56dd67cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef518a77a8947c6726ba30d56dd67cb">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType&amp; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiples each subvector of <code>*this</code> by the vector <em>other</em> </p>

</div>
</div>
<a id="a713694459d81b76e4f2a78e4d169f8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713694459d81b76e4f2a78e4d169f8d6">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_sum_op&lt;Scalar,typename OtherDerived::Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression of the sum of the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="a23ce2522d11c3362ca22252b2876812b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ce2522d11c3362ca22252b2876812b">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType&amp; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="a5e60616620df132d665b301bb9a304c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e60616620df132d665b301bb9a304c4">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_difference_op&lt;Scalar,typename OtherDerived::Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression of the difference between each subvector of <code>*this</code> and the vector <em>other</em> </p>

</div>
</div>
<a id="a6bb3a7315617f86f0c28ac05816cf6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb3a7315617f86f0c28ac05816cf6e3">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType&amp; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Substracts the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="aa154a8407885a9ad51504180f6d7a163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa154a8407885a9ad51504180f6d7a163">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression where each subvector is the quotient of the corresponding subvector of <code>*this</code> by the vector <em>other</em> </p>

</div>
</div>
<a id="a9efa0b81915c31535a929a46a79cab2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efa0b81915c31535a929a46a79cab2b">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType&amp; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides each subvector of <code>*this</code> by the vector <em>other</em> </p>

</div>
</div>
<a id="a7999eb8f50bb19ade54f3212d3c79680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7999eb8f50bb19ade54f3212d3c79680">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType&amp; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="a01bcd17504f30b55b4910ddb75598f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bcd17504f30b55b4910ddb75598f79">&#9670;&nbsp;</a></span>prod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">ProdReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::prod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the product of each column (or row) of the referenced expression.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the product of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().prod() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the product of each row:
 -0.134
-0.0933
  0.152
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#af119d9a4efe5a15cd83c1ccdf01b3a4f">DenseBase::prod()</a> </dd></dl>

</div>
</div>
<a id="a91a8087eb76e210b07192c81d362dd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a8087eb76e210b07192c81d362dd1e">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a reverse iterator to the last row (rowwise) or column (colwise) of the nested expression. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#aa9592e93b704f7712e8f33631a2efe8f">rend()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#aec95725eed4adb5ccf65fbb6e907d12e">crbegin()</a> </dd></dl>

</div>
</div>
<a id="aa73e8a0230fcc049346057ef1a6efe02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73e8a0230fcc049346057ef1a6efe02">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#a91a8087eb76e210b07192c81d362dd1e">rbegin()</a> </p>

</div>
</div>
<a id="ae92babb33ed5a91eb0c4de80a97eafca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92babb33ed5a91eb0c4de80a97eafca">&#9670;&nbsp;</a></span>redux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename BinaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ReduxReturnType&lt;BinaryOp&gt;::Type <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::redux </td>
          <td>(</td>
          <td class="paramtype">const BinaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>BinaryOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row or column vector expression of <code>*this</code> reduxed by <em>func</em> </dd></dl>
<p>The template parameter <em>BinaryOp</em> is the type of the functor of the custom redux operator. Note that func must be an associative operator.</p>
<dl class="section warning"><dt>Warning</dt><dd>the size along the reduction direction must be strictly positive, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a> </dd></dl>

</div>
</div>
<a id="aa9592e93b704f7712e8f33631a2efe8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9592e93b704f7712e8f33631a2efe8f">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a reverse iterator to the row (resp. column) before the first row (resp. column) of the nested expression </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#a57859b88a32b8b393a427c4cab3581a7">cend()</a> </dd></dl>

</div>
</div>
<a id="afeb3e3ceca37ae0a6e313f80743f767a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb3e3ceca37ae0a6e313f80743f767a">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#aa9592e93b704f7712e8f33631a2efe8f">rend()</a> </p>

</div>
</div>
<a id="a5f0c8dc9e9c4aeaa2057f15800f5c18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0c8dc9e9c4aeaa2057f15800f5c18c">&#9670;&nbsp;</a></span>replicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::<a class="el" href="classEigen_1_1Replicate.html">ReplicateReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of each column (or row) of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Vector3i v = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Vector3i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;v.rowwise().replicate(5) = ...&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; v.rowwise().replicate(5) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the vector v:
 7
-2
 6
v.rowwise().replicate(5) = ...
 7  7  7  7  7
-2 -2 -2 -2 -2
 6  6  6  6  6
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a5f0c8dc9e9c4aeaa2057f15800f5c18c">VectorwiseOp::replicate()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a60dadfe80b813d808e91e4521c722a8e">DenseBase::replicate()</a>, class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd></dl>

</div>
</div>
<a id="a81bfb88fe6415c7bfd9bdf15ef608aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bfb88fe6415c7bfd9bdf15ef608aaa">&#9670;&nbsp;</a></span>replicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;int Factor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt;ExpressionType,isVertical*Factor+isHorizontal,isHorizontal*Factor+isVertical&gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a>&#160;</td>
          <td class="paramname"><em>factor</em> = <code>Factor</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of each column (or row) of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line">MatrixXi m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">MatrixXi::Random</a>(2,3);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.colwise().replicate&lt;3&gt;() = ...&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.colwise().replicate&lt;3&gt;() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  6  9
-2  6 -6
m.colwise().replicate&lt;3&gt;() = ...
 7  6  9
-2  6 -6
 7  6  9
-2  6 -6
 7  6  9
-2  6 -6
</pre><dl class="section see"><dt>See also</dt><dd>VectorwiseOp::replicate(Index), <a class="el" href="classEigen_1_1DenseBase.html#a60dadfe80b813d808e91e4521c722a8e">DenseBase::replicate()</a>, class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd></dl>

</div>
</div>
<a id="ab8caf5367e2bd636536c8a0e0c89fe15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8caf5367e2bd636536c8a0e0c89fe15">&#9670;&nbsp;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable matrix expression where each column (or row) are reversed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#aeb0428f561b5757e2c85e8d72022eec1">reverse() const </a> </dd></dl>

</div>
</div>
<a id="aeb0428f561b5757e2c85e8d72022eec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0428f561b5757e2c85e8d72022eec1">&#9670;&nbsp;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a matrix expression where each column (or row) are reversed.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">MatrixXi m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">MatrixXi::Random</a>(3,4);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the rowwise reverse of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().reverse() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the colwise reverse of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().reverse() &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the coefficient (1,0) in the rowise reverse of m:&quot;</span> &lt;&lt; endl</div>
<div class="line">&lt;&lt; m.rowwise().reverse()(1,0) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Let us overwrite this coefficient with the value 4.&quot;</span> &lt;&lt; endl;</div>
<div class="line"><span class="comment">//m.colwise().reverse()(1,0) = 4;</span></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  6 -3  1
-2  9  6  0
 6 -6 -5  3
Here is the rowwise reverse of m:
 1 -3  6  7
 0  6  9 -2
 3 -5 -6  6
Here is the colwise reverse of m:
 6 -6 -5  3
-2  9  6  0
 7  6 -3  1
Here is the coefficient (1,0) in the rowise reverse of m:
0
Let us overwrite this coefficient with the value 4.
Now the matrix m is:
 7  6 -3  1
-2  9  6  0
 6 -6 -5  3
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a38ea394036d8b096abf322469c80198f">DenseBase::reverse()</a> </dd></dl>

</div>
</div>
<a id="ab9dd7c273eb2ba8defaab2d55156936b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dd7c273eb2ba8defaab2d55156936b">&#9670;&nbsp;</a></span>reverseInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverseInPlace</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the "in place" version of <a class="el" href="classEigen_1_1VectorwiseOp.html#aeb0428f561b5757e2c85e8d72022eec1">VectorwiseOp::reverse</a>: it reverses each column or row of <code>*this</code>.</p>
<p>In most cases it is probably better to simply use the reversed expression of a matrix. However, when reversing the matrix data itself is really needed, then this "in-place" version is probably the right choice because it provides the following additional benefits:</p><ul>
<li>less error prone: doing the same operation with .<a class="el" href="classEigen_1_1VectorwiseOp.html#ab8caf5367e2bd636536c8a0e0c89fe15">reverse()</a> requires special care: <div class="fragment"><div class="line">m = m.reverse().eval(); </div>
</div><!-- fragment --></li>
<li>this API enables reverse operations without the need for a temporary</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#adb8045155ea45f7961fc2a5170e1d921">DenseBase::reverseInPlace()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#ab8caf5367e2bd636536c8a0e0c89fe15">reverse()</a> </dd></dl>

</div>
</div>
<a id="a01474cf971473a73c919f6a99323d4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01474cf971473a73c919f6a99323d4f5">&#9670;&nbsp;</a></span>squaredNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SquaredNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::squaredNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the squared norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the square norm of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().squaredNorm() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the square norm of each row:
0.928
 1.01
0.884
</pre><dl class="section see"><dt>See also</dt><dd>DenseBase::squaredNorm() </dd></dl>

</div>
</div>
<a id="add48fd836be98ed280cac23518db0916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add48fd836be98ed280cac23518db0916">&#9670;&nbsp;</a></span>stableNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">StableNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::stableNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, avoiding underflow and overflow. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::stableNorm() </dd></dl>

</div>
</div>
<a id="a7030fc687c24d687ed7cd70733ba611c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7030fc687c24d687ed7cd70733ba611c">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SumReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the sum of each column (or row) of the referenced expression.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().sum() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the sum of each row:
 0.948
  1.15
-0.483
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#addd7080d5c202795820e361768d0140c">DenseBase::sum()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a595c33d2a82427a1159568b0b8438554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595c33d2a82427a1159568b0b8438554">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">random_access_iterator_type <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the const version of iterator (aka read-only) </p>

</div>
</div>
<a id="a9fb8aaf24528efcdac1782aacf99b8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb8aaf24528efcdac1782aacf99b8dd">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">random_access_iterator_type <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">RandomAccessIterator</a> iterator type over the columns or rows as returned by the <a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a> and <a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end()</a> methods. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="VectorwiseOp_8h_source.html">VectorwiseOp.h</a></li>
<li><a class="el" href="Replicate_8h_source.html">Replicate.h</a></li>
<li><a class="el" href="Reverse_8h_source.html">Reverse.h</a></li>
<li><a class="el" href="Homogeneous_8h_source.html">Homogeneous.h</a></li>
<li><a class="el" href="OrthoMethods_8h_source.html">OrthoMethods.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a></li>
    <li class="footer">Generated on Wed Aug 18 2021 14:57:21 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
