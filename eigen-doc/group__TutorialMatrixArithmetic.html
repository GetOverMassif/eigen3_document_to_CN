<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: Matrix 和 vector 算法</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<!--
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better know about our user community by answering the following short survey:  <a href="https://forms.gle/wpyrxWi18ox9Z5ae9">https://forms.gle/wpyrxWi18ox9Z5ae9</a></div>
-->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.4.0 (git rev e3e74001f7c4bf95f0dde572e8a08c5b2918a3ab)</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__TutorialMatrixArithmetic.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Matrix 和 vector 算法<div class="ingroups"><a class="el" href="group__DenseMatrixManipulation__chapter.html">稠密矩阵和数组的操作</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>This page aims to provide an overview and some details on how to perform arithmetic between matrices, vectors and scalars with <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>.</p>
<h1><a class="anchor" id="TutorialArithmeticIntroduction"></a>
Introduction</h1>
<p><a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> offers matrix/vector arithmetic operations either through overloads of common C++ arithmetic operators such as +, -, *, or through special methods such as dot(), cross(), etc. For the <a class="el" href="classEigen_1_1Matrix.html" title="Matrix 类, also used for vectors and row-vectors.">Matrix</a> class (matrices and vectors), operators are only overloaded to support linear-algebraic operations. For example, <code>matrix1</code> <code>*</code> <code>matrix2</code> means matrix-matrix product, and <code>vector</code> <code>+</code> <code>scalar</code> is just not allowed. If you want to perform all kinds of array operations, not linear algebra, see the <a class="el" href="group__TutorialArrayClass.html">next page</a>.</p>
<h1><a class="anchor" id="TutorialArithmeticAddSub"></a>
Addition and subtraction</h1>
<p>The left hand side and right hand side must, of course, have the same numbers of rows and of columns. They must also have the same <code>Scalar</code> type, as <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> doesn't do automatic type promotion. The operators at hand here are: </p><ul>
<li>binary operator + as in <code>a+b</code> </li>
<li>binary operator - as in <code>a-b</code> </li>
<li>unary operator - as in <code>-a</code> </li>
<li>compound operator += as in <code>a+=b</code> </li>
<li>compound operator -= as in <code>a-=b</code> </li>
</ul>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Matrix2d a;</div>
<div class="line">  a &lt;&lt; 1, 2,</div>
<div class="line">       3, 4;</div>
<div class="line">  MatrixXd b(2,2);</div>
<div class="line">  b &lt;&lt; 2, 3,</div>
<div class="line">       1, 4;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;a + b =\n&quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;a - b =\n&quot;</span> &lt;&lt; a - b &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Doing a += b;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  a += b;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Now a =\n&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</div>
<div class="line">  Vector3d v(1,2,3);</div>
<div class="line">  Vector3d w(1,0,0);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;-v + w - v =\n&quot;</span> &lt;&lt; -v + w - v &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceEigen_html"><div class="ttname"><a href="namespaceEigen.html">Eigen</a></div><div class="ttdoc">Namespace containing all symbols from the Eigen library.</div><div class="ttdef"><b>Definition:</b> Core:141</div></div>
</div><!-- fragment -->  </td><td><pre class="fragment">a + b =
3 5
4 8
a - b =
-1 -1
 2  0
Doing a += b;
Now a =
3 5
4 8
-v + w - v =
-1
-4
-6
</pre> </td></tr>
</table>
<h1><a class="anchor" id="TutorialArithmeticScalarMulDiv"></a>
Scalar multiplication and division</h1>
<p>Multiplication and division by a scalar is very simple too. The operators at hand here are: </p><ul>
<li>binary operator * as in <code>matrix*scalar</code> </li>
<li>binary operator * as in <code>scalar*matrix</code> </li>
<li>binary operator / as in <code>matrix/scalar</code> </li>
<li>compound operator *= as in <code>matrix*=scalar</code> </li>
<li>compound operator /= as in <code>matrix/=scalar</code> </li>
</ul>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Matrix2d a;</div>
<div class="line">  a &lt;&lt; 1, 2,</div>
<div class="line">       3, 4;</div>
<div class="line">  Vector3d v(1,2,3);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;a * 2.5 =\n&quot;</span> &lt;&lt; a * 2.5 &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;0.1 * v =\n&quot;</span> &lt;&lt; 0.1 * v &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Doing v *= 2;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  v *= 2;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Now v =\n&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td><pre class="fragment">a * 2.5 =
2.5   5
7.5  10
0.1 * v =
0.1
0.2
0.3
Doing v *= 2;
Now v =
2
4
6
</pre> </td></tr>
</table>
<h1><a class="anchor" id="TutorialArithmeticMentionXprTemplates"></a>
A note about expression templates</h1>
<p>This is an advanced topic that we explain on <a class="el" href="TopicEigenExpressionTemplates.html">this page</a>, but it is useful to just mention it now. In <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>, arithmetic operators such as <code>operator+</code> don't perform any computation by themselves, they just return an "expression object" describing the computation to be performed. The actual computation happens later, when the whole expression is evaluated, typically in <code>operator=</code>. While this might sound heavy, any modern optimizing compiler is able to optimize away that abstraction and the result is perfectly optimized code. For example, when you do: </p><div class="fragment"><div class="line">VectorXf a(50), b(50), c(50), d(50);</div>
<div class="line">...</div>
<div class="line">a = 3*b + 4*c + 5*d;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> compiles it to just one for loop, so that the arrays are traversed only once. Simplifying (e.g. ignoring SIMD optimizations), this loop looks like this: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 50; ++i)</div>
<div class="line">  a[i] = 3*b[i] + 4*c[i] + 5*d[i];</div>
</div><!-- fragment --><p> Thus, you should not be afraid of using relatively large arithmetic expressions with <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>: it only gives <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> more opportunities for optimization.</p>
<h1><a class="anchor" id="TutorialArithmeticTranspose"></a>
Transposition and conjugation</h1>
<p>The transpose \( a^T \), conjugate \( \bar{a} \), and adjoint (i.e., conjugate transpose) \( a^* \) of a matrix or vector \( a \) are obtained by the member functions <a class="el" href="classEigen_1_1DenseBase.html#ac8952c19644a4ac7e41bea45c19b909c">transpose()</a>, <a class="el" href="">conjugate()</a>, and <a class="el" href="classEigen_1_1MatrixBase.html#afacca1f88da57e5cd87dd07c8ff926bb">adjoint()</a>, respectively.</p>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line">MatrixXcf a = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">MatrixXcf::Random</a>(2,2);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix a\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix a^T\n&quot;</span> &lt;&lt; a.transpose() &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the conjugate of a\n&quot;</span> &lt;&lt; a.conjugate() &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix a^*\n&quot;</span> &lt;&lt; a.adjoint() &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_ae814abb451b48ed872819192dc188c19"><div class="ttname"><a href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Eigen::DenseBase::Random</a></div><div class="ttdeci">static const RandomReturnType Random()</div><div class="ttdef"><b>Definition:</b> Random.h:113</div></div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix a
 (-0.211,0.68) (-0.605,0.823)
 (0.597,0.566)  (0.536,-0.33)
Here is the matrix a^T
 (-0.211,0.68)  (0.597,0.566)
(-0.605,0.823)  (0.536,-0.33)
Here is the conjugate of a
 (-0.211,-0.68) (-0.605,-0.823)
 (0.597,-0.566)    (0.536,0.33)
Here is the matrix a^*
 (-0.211,-0.68)  (0.597,-0.566)
(-0.605,-0.823)    (0.536,0.33)
</pre> </td></tr>
</table>
<p>For real matrices, <code>conjugate()</code> is a no-operation, and so <code>adjoint()</code> is equivalent to <code>transpose()</code>.</p>
<p>As for basic arithmetic operators, <code>transpose()</code> and <code>adjoint()</code> simply return a proxy object without doing the actual transposition. If you do <code>b = a.transpose()</code>, then the transpose is evaluated at the same time as the result is written into <code>b</code>. However, there is a complication here. If you do <code>a = a.transpose()</code>, then <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> starts writing the result into <code>a</code> before the evaluation of the transpose is finished. Therefore, the instruction <code>a = a.transpose()</code> does not replace <code>a</code> with its transpose, as one would expect: </p><table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line">Matrix2i a; a &lt;&lt; 1, 2, 3, 4;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">a = a.transpose(); <span class="comment">// !!! do NOT do this !!!</span></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;and the result of the aliasing effect:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix a:
1 2
3 4
and the result of the aliasing effect:
1 2
2 4
</pre> </td></tr>
</table>
<p>This is the so-called <a class="el" href="group__TopicAliasing.html">aliasing issue</a>. In "debug mode", i.e., when <a class="el" href="TopicAssertions.html">assertions</a> have not been disabled, such common pitfalls are automatically detected.</p>
<p>For <em>in-place</em> transposition, as for instance in <code>a = a.transpose()</code>, simply use the <a class="el" href="classEigen_1_1DenseBase.html#ac501bd942994af7a95d95bee7a16ad2a">transposeInPlace()</a> function: </p><table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line">MatrixXf a(2,3); a &lt;&lt; 1, 2, 3, 4, 5, 6;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the initial matrix a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">a.transposeInPlace();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;and after being transposed:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the initial matrix a:
1 2 3
4 5 6
and after being transposed:
1 4
2 5
3 6
</pre> </td></tr>
</table>
<p>There is also the <a class="el" href="classEigen_1_1MatrixBase.html#a51c5982c1f64e45a939515b701fa6f4a">adjointInPlace()</a> function for complex matrices.</p>
<h1><a class="anchor" id="TutorialArithmeticMatrixMul"></a>
Matrix-matrix and matrix-vector multiplication</h1>
<p>Matrix-matrix multiplication is again done with <code>operator*</code>. Since vectors are a special case of matrices, they are implicitly handled there too, so matrix-vector product is really just a special case of matrix-matrix product, and so is vector-vector outer product. Thus, all these cases are handled by just two operators: </p><ul>
<li>binary operator * as in <code>a*b</code> </li>
<li>compound operator *= as in <code>a*=b</code> (this multiplies on the right: <code>a*=b</code> is equivalent to <code>a = a*b</code>)</li>
</ul>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Matrix2d mat;</div>
<div class="line">  mat &lt;&lt; 1, 2,</div>
<div class="line">         3, 4;</div>
<div class="line">  Vector2d u(-1,1), v(2,0);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Here is mat*mat:\n&quot;</span> &lt;&lt; mat*mat &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Here is mat*u:\n&quot;</span> &lt;&lt; mat*u &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Here is u^T*mat:\n&quot;</span> &lt;&lt; u.transpose()*mat &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Here is u^T*v:\n&quot;</span> &lt;&lt; u.transpose()*v &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Here is u*v^T:\n&quot;</span> &lt;&lt; u*v.transpose() &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Let&#39;s multiply mat by itself&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  mat = mat*mat;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Now mat is mat:\n&quot;</span> &lt;&lt; mat &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is mat*mat:
 7 10
15 22
Here is mat*u:
1
1
Here is u^T*mat:
2 2
Here is u^T*v:
-2
Here is u*v^T:
-2 -0
 2  0
Let's multiply mat by itself
Now mat is mat:
 7 10
15 22
</pre> </td></tr>
</table>
<p>Note: if you read the above paragraph on expression templates and are worried that doing <code>m=m*m</code> might cause aliasing issues, be reassured for now: <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> treats matrix multiplication as a special case and takes care of introducing a temporary here, so it will compile <code>m=m*m</code> as: </p><div class="fragment"><div class="line">tmp = m*m;</div>
<div class="line">m = tmp;</div>
</div><!-- fragment --><p> If you know your matrix product can be safely evaluated into the destination matrix without aliasing issue, then you can use the <a class="el" href="classEigen_1_1MatrixBase.html#a2c1085de7645f23f240876388457da0b">noalias()</a> function to avoid the temporary, e.g.: </p><div class="fragment"><div class="line">c.noalias() += a * b;</div>
</div><!-- fragment --><p> For more details on this topic, see the page on <a class="el" href="group__TopicAliasing.html">aliasing</a>.</p>
<p><b>Note:</b> for BLAS users worried about performance, expressions such as <code>c.noalias() -= 2 * a.adjoint() * b;</code> are fully optimized and trigger a single gemm-like function call.</p>
<h1><a class="anchor" id="TutorialArithmeticDotAndCross"></a>
Dot product and cross product</h1>
<p>For dot product and cross product, you need the <a class="el" href="classEigen_1_1MatrixBase.html#adfd32bf5fcf6ee603c924dde9bf7bc39">dot()</a> and <a class="el" href="group__Geometry__Module.html#ga0024b44eca99cb7135887c2aaf319d28">cross()</a> methods. Of course, the dot product can also be obtained as a 1x1 matrix as u.adjoint()*v. </p><table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Vector3d v(1,2,3);</div>
<div class="line">  Vector3d w(0,1,2);</div>
<div class="line"> </div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Dot product: &quot;</span> &lt;&lt; v.dot(w) &lt;&lt; endl;</div>
<div class="line">  <span class="keywordtype">double</span> dp = v.adjoint()*w; <span class="comment">// automatic conversion of the inner product to a scalar</span></div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Dot product via a matrix product: &quot;</span> &lt;&lt; dp &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Cross product:\n&quot;</span> &lt;&lt; v.cross(w) &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Dot product: 8
Dot product via a matrix product: 8
Cross product:
 1
-2
 1
</pre> </td></tr>
</table>
<p>Remember that cross product is only for vectors of size 3. Dot product is for vectors of any sizes. When using complex numbers, <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>'s dot product is conjugate-linear in the first variable and linear in the second variable.</p>
<h1><a class="anchor" id="TutorialArithmeticRedux"></a>
Basic arithmetic reduction operations</h1>
<p><a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> also provides some reduction operations to reduce a given matrix or vector to a single value such as the sum (computed by <a class="el" href="classEigen_1_1DenseBase.html#addd7080d5c202795820e361768d0140c">sum()</a>), product (<a class="el" href="classEigen_1_1DenseBase.html#af119d9a4efe5a15cd83c1ccdf01b3a4f">prod()</a>), or the maximum (<a class="el" href="classEigen_1_1DenseBase.html#a7e6987d106f1cca3ac6ab36d288cc8e1">maxCoeff()</a>) and minimum (<a class="el" href="classEigen_1_1DenseBase.html#a0739f9c868c331031c7810e21838dcb2">minCoeff()</a>) of all its coefficients.</p>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Eigen::Matrix2d</a> mat;</div>
<div class="line">  mat &lt;&lt; 1, 2,</div>
<div class="line">         3, 4;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Here is mat.sum():       &quot;</span> &lt;&lt; mat.<a class="code" href="classEigen_1_1DenseBase.html#addd7080d5c202795820e361768d0140c">sum</a>()       &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Here is mat.prod():      &quot;</span> &lt;&lt; mat.<a class="code" href="classEigen_1_1DenseBase.html#af119d9a4efe5a15cd83c1ccdf01b3a4f">prod</a>()      &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Here is mat.mean():      &quot;</span> &lt;&lt; mat.<a class="code" href="classEigen_1_1DenseBase.html#a21ac6c0419a72ad7a88ea0bc189017d7">mean</a>()      &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Here is mat.minCoeff():  &quot;</span> &lt;&lt; mat.<a class="code" href="classEigen_1_1DenseBase.html#a0739f9c868c331031c7810e21838dcb2">minCoeff</a>()  &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Here is mat.maxCoeff():  &quot;</span> &lt;&lt; mat.<a class="code" href="classEigen_1_1DenseBase.html#a7e6987d106f1cca3ac6ab36d288cc8e1">maxCoeff</a>()  &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Here is mat.trace():     &quot;</span> &lt;&lt; mat.<a class="code" href="classEigen_1_1MatrixBase.html#a544b609f65eb2bd3e368b3fc2d79479e">trace</a>()     &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a0739f9c868c331031c7810e21838dcb2"><div class="ttname"><a href="classEigen_1_1DenseBase.html#a0739f9c868c331031c7810e21838dcb2">Eigen::DenseBase::minCoeff</a></div><div class="ttdeci">internal::traits&lt; Derived &gt;::Scalar minCoeff() const</div><div class="ttdef"><b>Definition:</b> Redux.h:431</div></div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a21ac6c0419a72ad7a88ea0bc189017d7"><div class="ttname"><a href="classEigen_1_1DenseBase.html#a21ac6c0419a72ad7a88ea0bc189017d7">Eigen::DenseBase::mean</a></div><div class="ttdeci">Scalar mean() const</div><div class="ttdef"><b>Definition:</b> Redux.h:472</div></div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_a7e6987d106f1cca3ac6ab36d288cc8e1"><div class="ttname"><a href="classEigen_1_1DenseBase.html#a7e6987d106f1cca3ac6ab36d288cc8e1">Eigen::DenseBase::maxCoeff</a></div><div class="ttdeci">internal::traits&lt; Derived &gt;::Scalar maxCoeff() const</div><div class="ttdef"><b>Definition:</b> Redux.h:446</div></div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_addd7080d5c202795820e361768d0140c"><div class="ttname"><a href="classEigen_1_1DenseBase.html#addd7080d5c202795820e361768d0140c">Eigen::DenseBase::sum</a></div><div class="ttdeci">Scalar sum() const</div><div class="ttdef"><b>Definition:</b> Redux.h:459</div></div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_af119d9a4efe5a15cd83c1ccdf01b3a4f"><div class="ttname"><a href="classEigen_1_1DenseBase.html#af119d9a4efe5a15cd83c1ccdf01b3a4f">Eigen::DenseBase::prod</a></div><div class="ttdeci">Scalar prod() const</div><div class="ttdef"><b>Definition:</b> Redux.h:493</div></div>
<div class="ttc" id="aclassEigen_1_1MatrixBase_html_a544b609f65eb2bd3e368b3fc2d79479e"><div class="ttname"><a href="classEigen_1_1MatrixBase.html#a544b609f65eb2bd3e368b3fc2d79479e">Eigen::MatrixBase::trace</a></div><div class="ttdeci">Scalar trace() const</div><div class="ttdef"><b>Definition:</b> Redux.h:508</div></div>
<div class="ttc" id="aclassEigen_1_1Matrix_html"><div class="ttname"><a href="classEigen_1_1Matrix.html">Eigen::Matrix</a></div><div class="ttdoc">Matrix 类, also used for vectors and row-vectors.</div><div class="ttdef"><b>Definition:</b> Matrix.h:180</div></div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is mat.sum():       10
Here is mat.prod():      24
Here is mat.mean():      2.5
Here is mat.minCoeff():  1
Here is mat.maxCoeff():  4
Here is mat.trace():     5
</pre> </td></tr>
</table>
<p>The <em>trace</em> of a matrix, as returned by the function <a class="el" href="classEigen_1_1MatrixBase.html#a544b609f65eb2bd3e368b3fc2d79479e">trace()</a>, is the sum of the diagonal coefficients and can also be computed as efficiently using <code>a.diagonal().sum()</code>, as we will see later on.</p>
<p>There also exist variants of the <code>minCoeff</code> and <code>maxCoeff</code> functions returning the coordinates of the respective coefficient via the arguments:</p>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line">  Matrix3f m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3f::Random</a>();</div>
<div class="line">  std::ptrdiff_t i, j;</div>
<div class="line">  <span class="keywordtype">float</span> minOfM = m.minCoeff(&amp;i,&amp;j);</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:\n&quot;</span> &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Its minimum coefficient (&quot;</span> &lt;&lt; minOfM </div>
<div class="line">       &lt;&lt; <span class="stringliteral">&quot;) is at position (&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot;)\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  RowVector4i v = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">RowVector4i::Random</a>();</div>
<div class="line">  <span class="keywordtype">int</span> maxOfV = v.maxCoeff(&amp;i);</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v: &quot;</span> &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Its maximum coefficient (&quot;</span> &lt;&lt; maxOfV </div>
<div class="line">       &lt;&lt; <span class="stringliteral">&quot;) is at position &quot;</span> &lt;&lt; i &lt;&lt; endl;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Its minimum coefficient (-0.605) is at position (2,1)

Here is the vector v:  1  0  3 -3
Its maximum coefficient (3) is at position 2
</pre> </td></tr>
</table>
<h1><a class="anchor" id="TutorialArithmeticValidity"></a>
Validity of operations</h1>
<p><a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> checks the validity of the operations that you perform. When possible, it checks them at compile time, producing compilation errors. These error messages can be long and ugly, but <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> writes the important message in UPPERCASE_LETTERS_SO_IT_STANDS_OUT. For example: </p><div class="fragment"><div class="line">Matrix3f m;</div>
<div class="line">Vector4f v;</div>
<div class="line">v = m*v;      <span class="comment">// Compile-time error: YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES</span></div>
</div><!-- fragment --><p>Of course, in many cases, for example when checking dynamic sizes, the check cannot be performed at compile time. <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> then uses runtime assertions. This means that the program will abort with an error message when executing an illegal operation if it is run in "debug mode", and it will probably crash if assertions are turned off.</p>
<div class="fragment"><div class="line">MatrixXf m(3,3);</div>
<div class="line">VectorXf v(4);</div>
<div class="line">v = m * v; <span class="comment">// Run-time assertion failure here: &quot;invalid matrix product&quot;</span></div>
</div><!-- fragment --><p>For more details on this topic, see <a class="el" href="TopicAssertions.html">this page</a>. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 18 2021 14:57:20 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
