<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: 线性代数和分解问题</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<!--
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better know about our user community by answering the following short survey:  <a href="https://forms.gle/wpyrxWi18ox9Z5ae9">https://forms.gle/wpyrxWi18ox9Z5ae9</a></div>
-->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.4.0 (git rev e3e74001f7c4bf95f0dde572e8a08c5b2918a3ab)</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__TutorialLinearAlgebra.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">线性代数和分解问题<div class="ingroups"><a class="el" href="group__DenseLinearSolvers__chapter.html">稠密线性问题和分解</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>This page explains how to solve linear systems, compute various decompositions such as LU, QR, SVD, eigendecompositions... After reading this page, don't miss our <a class="el" href="group__TopicLinearAlgebraDecompositions.html">catalogue </a> of dense matrix decompositions.</p>
<h1><a class="anchor" id="TutorialLinAlgBasicSolve"></a>
Basic linear solving</h1>
<p><b>The</b> <b>problem:</b> You have a system of equations, that you have written as a single matrix equation </p><p class="formulaDsp">
\[ Ax \: = \: b \]
</p>
<p> Where <em>A</em> and <em>b</em> are matrices (<em>b</em> could be a vector, as a special case). You want to find a solution <em>x</em>.</p>
<p><b>The</b> <b>solution:</b> You can choose between various decompositions, depending on the properties of your matrix <em>A</em>, and depending on whether you favor speed or accuracy. However, let's start with an example that works in all cases, and is a good compromise: </p><table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   Matrix3f A;</div>
<div class="line">   Vector3f b;</div>
<div class="line">   A &lt;&lt; 1,2,3,  4,5,6,  7,8,10;</div>
<div class="line">   b &lt;&lt; 3, 3, 4;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector b:\n&quot;</span> &lt;&lt; b &lt;&lt; endl;</div>
<div class="line">   Vector3f x = A.colPivHouseholderQr().solve(b);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;The solution is:\n&quot;</span> &lt;&lt; x &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceEigen_html"><div class="ttname"><a href="namespaceEigen.html">Eigen</a></div><div class="ttdoc">Namespace containing all symbols from the Eigen library.</div><div class="ttdef"><b>Definition:</b> Core:141</div></div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix A:
 1  2  3
 4  5  6
 7  8 10
Here is the vector b:
3
3
4
The solution is:
-2
 1
 1
</pre>   </td></tr>
</table>
<p>In this example, the colPivHouseholderQr() method returns an object of class <a class="el" href="classEigen_1_1ColPivHouseholderQR.html" title="Householder rank-revealing QR decomposition of a matrix with column-pivoting.">ColPivHouseholderQR</a>. Since here the matrix is of type Matrix3f, this line could have been replaced by: </p><div class="fragment"><div class="line">ColPivHouseholderQR&lt;Matrix3f&gt; dec(A);</div>
<div class="line">Vector3f x = dec.solve(b);</div>
</div><!-- fragment --><p>Here, <a class="el" href="classEigen_1_1ColPivHouseholderQR.html" title="Householder rank-revealing QR decomposition of a matrix with column-pivoting.">ColPivHouseholderQR</a> is a QR decomposition with column pivoting. It's a good compromise for this tutorial, as it works for all matrices while being quite fast. Here is a table of some other decompositions that you can choose from, depending on your matrix, the problem you are trying to solve, and the trade-off you want to make:</p>
<table class="manual">
<tr>
<th>Decomposition </th><th>Method </th><th>Requirements<br  />
on the matrix </th><th>Speed<br  />
 (small-to-medium) </th><th>Speed<br  />
 (large) </th><th>Accuracy  </th></tr>
<tr>
<td><a class="el" href="classEigen_1_1PartialPivLU.html" title="LU decomposition of a matrix with partial pivoting, and related features.">PartialPivLU</a> </td><td>partialPivLu() </td><td>Invertible </td><td>++ </td><td>++ </td><td>+  </td></tr>
<tr class="alt">
<td><a class="el" href="classEigen_1_1FullPivLU.html" title="LU decomposition of a matrix with complete pivoting, and related features.">FullPivLU</a> </td><td>fullPivLu() </td><td>None </td><td>- </td><td>- - </td><td>+++  </td></tr>
<tr>
<td><a class="el" href="classEigen_1_1HouseholderQR.html" title="Householder QR decomposition of a matrix.">HouseholderQR</a> </td><td>householderQr() </td><td>None </td><td>++ </td><td>++ </td><td>+  </td></tr>
<tr class="alt">
<td><a class="el" href="classEigen_1_1ColPivHouseholderQR.html" title="Householder rank-revealing QR decomposition of a matrix with column-pivoting.">ColPivHouseholderQR</a> </td><td>colPivHouseholderQr() </td><td>None </td><td>+ </td><td>- </td><td>+++  </td></tr>
<tr>
<td><a class="el" href="classEigen_1_1FullPivHouseholderQR.html" title="Householder rank-revealing QR decomposition of a matrix with full pivoting.">FullPivHouseholderQR</a> </td><td>fullPivHouseholderQr() </td><td>None </td><td>- </td><td>- - </td><td>+++  </td></tr>
<tr class="alt">
<td><a class="el" href="classEigen_1_1CompleteOrthogonalDecomposition.html" title="Complete orthogonal decomposition (COD) of a matrix.">CompleteOrthogonalDecomposition</a> </td><td>completeOrthogonalDecomposition() </td><td>None </td><td>+ </td><td>- </td><td>+++  </td></tr>
<tr class="alt">
<td><a class="el" href="classEigen_1_1LLT.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a> </td><td>llt() </td><td>Positive definite </td><td>+++ </td><td>+++ </td><td>+  </td></tr>
<tr>
<td><a class="el" href="classEigen_1_1LDLT.html" title="Robust Cholesky decomposition of a matrix with pivoting.">LDLT</a> </td><td>ldlt() </td><td>Positive or negative<br  />
 semidefinite </td><td>+++ </td><td>+ </td><td>++  </td></tr>
<tr class="alt">
<td><a class="el" href="classEigen_1_1BDCSVD.html" title="class Bidiagonal Divide and Conquer SVD">BDCSVD</a> </td><td>bdcSvd() </td><td>None </td><td>- </td><td>- </td><td>+++  </td></tr>
<tr class="alt">
<td><a class="el" href="classEigen_1_1JacobiSVD.html" title="Two-sided Jacobi SVD decomposition of a rectangular matrix.">JacobiSVD</a> </td><td>jacobiSvd() </td><td>None </td><td>- </td><td>- - - </td><td>+++  </td></tr>
</table>
<p>To get an overview of the true relative speed of the different decompositions, check this <a class="el" href="group__DenseDecompositionBenchmark.html">benchmark </a>.</p>
<p>All of these decompositions offer a solve() method that works as in the above example.</p>
<p>If you know more about the properties of your matrix, you can use the above table to select the best method. For example, a good choice for solving linear systems with a non-symmetric matrix of full rank is <a class="el" href="classEigen_1_1PartialPivLU.html" title="LU decomposition of a matrix with partial pivoting, and related features.">PartialPivLU</a>. If you know that your matrix is also symmetric and positive definite, the above table says that a very good choice is the <a class="el" href="classEigen_1_1LLT.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a> or <a class="el" href="classEigen_1_1LDLT.html" title="Robust Cholesky decomposition of a matrix with pivoting.">LDLT</a> decomposition. Here's an example, also demonstrating that using a general matrix (not a vector) as right hand side is possible:</p>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   Matrix2f A, b;</div>
<div class="line">   A &lt;&lt; 2, -1, -1, 3;</div>
<div class="line">   b &lt;&lt; 1, 2, 3, 1;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is the right hand side b:\n&quot;</span> &lt;&lt; b &lt;&lt; endl;</div>
<div class="line">   Matrix2f x = A.ldlt().solve(b);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;The solution is:\n&quot;</span> &lt;&lt; x &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix A:
 2 -1
-1  3
Here is the right hand side b:
1 2
3 1
The solution is:
1.2 1.4
1.4 0.8
</pre>   </td></tr>
</table>
<p>For a <a class="el" href="group__TopicLinearAlgebraDecompositions.html">much more complete table</a> comparing all decompositions supported by <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> (notice that <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> supports many other decompositions), see our special page on <a class="el" href="group__TopicLinearAlgebraDecompositions.html">this topic</a>.</p>
<h1><a class="anchor" id="TutorialLinAlgLeastsquares"></a>
Least squares solving</h1>
<p>The most general and accurate method to solve under- or over-determined linear systems in the least squares sense, is the SVD decomposition. <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> provides two implementations. The recommended one is the <a class="el" href="classEigen_1_1BDCSVD.html" title="class Bidiagonal Divide and Conquer SVD">BDCSVD</a> class, which scales well for large problems and automatically falls back to the <a class="el" href="classEigen_1_1JacobiSVD.html" title="Two-sided Jacobi SVD decomposition of a rectangular matrix.">JacobiSVD</a> class for smaller problems. For both classes, their solve() method solved the linear system in the least-squares sense.</p>
<p>Here is an example: </p><table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   MatrixXf A = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">MatrixXf::Random</a>(3, 2);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</div>
<div class="line">   VectorXf b = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">VectorXf::Random</a>(3);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is the right hand side b:\n&quot;</span> &lt;&lt; b &lt;&lt; endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;The least-squares solution is:\n&quot;</span></div>
<div class="line">        &lt;&lt; A.bdcSvd(<a class="code" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9aa7fb4e98834788d0b1b0f2b8467d2527">ComputeThinU</a> | <a class="code" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a540036417bfecf2e791a70948c227f47">ComputeThinV</a>).solve(b) &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassEigen_1_1DenseBase_html_ae814abb451b48ed872819192dc188c19"><div class="ttname"><a href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Eigen::DenseBase::Random</a></div><div class="ttdeci">static const RandomReturnType Random()</div><div class="ttdef"><b>Definition:</b> Random.h:113</div></div>
<div class="ttc" id="agroup__enums_html_ggae3e239fb70022eb8747994cf5d68b4a9a540036417bfecf2e791a70948c227f47"><div class="ttname"><a href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a540036417bfecf2e791a70948c227f47">Eigen::ComputeThinV</a></div><div class="ttdeci">@ ComputeThinV</div><div class="ttdef"><b>Definition:</b> Constants.h:399</div></div>
<div class="ttc" id="agroup__enums_html_ggae3e239fb70022eb8747994cf5d68b4a9aa7fb4e98834788d0b1b0f2b8467d2527"><div class="ttname"><a href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9aa7fb4e98834788d0b1b0f2b8467d2527">Eigen::ComputeThinU</a></div><div class="ttdeci">@ ComputeThinU</div><div class="ttdef"><b>Definition:</b> Constants.h:395</div></div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix A:
  0.68  0.597
-0.211  0.823
 0.566 -0.605
Here is the right hand side b:
 -0.33
 0.536
-0.444
The least-squares solution is:
-0.67
0.314
</pre>   </td></tr>
</table>
<p>An alternative to the SVD, which is usually faster and about as accurate, is <a class="el" href="classEigen_1_1CompleteOrthogonalDecomposition.html" title="Complete orthogonal decomposition (COD) of a matrix.">CompleteOrthogonalDecomposition</a>.</p>
<p>Again, if you know more about the problem, the table above contains methods that are potentially faster. If your matrix is full rank, HouseHolderQR is the method of choice. If your matrix is full rank and well conditioned, using the Cholesky decomposition (<a class="el" href="classEigen_1_1LLT.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a>) on the matrix of the normal equations can be faster still. Our page on <a class="el" href="group__LeastSquares.html">least squares solving </a> has more details.</p>
<h1><a class="anchor" id="TutorialLinAlgSolutionExists"></a>
Checking if a matrix is singular</h1>
<p>Only you know what error margin you want to allow for a solution to be considered valid. So <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> lets you do this computation for yourself, if you want to, as in this example:</p>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   MatrixXd A = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">MatrixXd::Random</a>(100,100);</div>
<div class="line">   MatrixXd b = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">MatrixXd::Random</a>(100,50);</div>
<div class="line">   MatrixXd x = A.fullPivLu().solve(b);</div>
<div class="line">   <span class="keywordtype">double</span> relative_error = (A*x - b).norm() / b.norm(); <span class="comment">// norm() is L2 norm</span></div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;The relative error is:\n&quot;</span> &lt;&lt; relative_error &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td><pre class="fragment">The relative error is:
2.31495e-14
</pre>   </td></tr>
</table>
<h1><a class="anchor" id="TutorialLinAlgEigensolving"></a>
Computing eigenvalues and eigenvectors</h1>
<p>You need an eigendecomposition here, see available such decompositions on <a class="el" href="group__TopicLinearAlgebraDecompositions.html">this page</a>. Make sure to check if your matrix is self-adjoint, as is often the case in these problems. Here's an example using <a class="el" href="classEigen_1_1SelfAdjointEigenSolver.html" title="Computes eigenvalues and eigenvectors of selfadjoint matrices.">SelfAdjointEigenSolver</a>, it could easily be adapted to general matrices using <a class="el" href="classEigen_1_1EigenSolver.html" title="Computes eigenvalues and eigenvectors of general matrices.">EigenSolver</a> or <a class="el" href="classEigen_1_1ComplexEigenSolver.html" title="Computes eigenvalues and eigenvectors of general complex matrices.">ComplexEigenSolver</a>.</p>
<p>The computation of eigenvalues and eigenvectors does not necessarily converge, but such failure to converge is very rare. The call to info() is to check for this possibility.</p>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   Matrix2f A;</div>
<div class="line">   A &lt;&lt; 1, 2, 2, 3;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</div>
<div class="line">   SelfAdjointEigenSolver&lt;Matrix2f&gt; eigensolver(A);</div>
<div class="line">   <span class="keywordflow">if</span> (eigensolver.info() != <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf">Success</a>) abort();</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;The eigenvalues of A are:\n&quot;</span> &lt;&lt; eigensolver.eigenvalues() &lt;&lt; endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s a matrix whose columns are eigenvectors of A \n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;corresponding to these eigenvalues:\n&quot;</span></div>
<div class="line">        &lt;&lt; eigensolver.eigenvectors() &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__enums_html_gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf"><div class="ttname"><a href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf">Eigen::Success</a></div><div class="ttdeci">@ Success</div><div class="ttdef"><b>Definition:</b> Constants.h:442</div></div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix A:
1 2
2 3
The eigenvalues of A are:
-0.236
  4.24
Here's a matrix whose columns are eigenvectors of A 
corresponding to these eigenvalues:
-0.851 -0.526
 0.526 -0.851
</pre>   </td></tr>
</table>
<h1><a class="anchor" id="TutorialLinAlgInverse"></a>
Computing inverse and determinant</h1>
<p>First of all, make sure that you really want this. While inverse and determinant are fundamental mathematical concepts, in <em>numerical</em> linear algebra they are not as useful as in pure mathematics. <a class="el" href="classEigen_1_1Inverse.html" title="Expression of the inverse of another expression.">Inverse</a> computations are often advantageously replaced by solve() operations, and the determinant is often <em>not</em> a good way of checking if a matrix is invertible.</p>
<p>However, for <em>very</em> <em>small</em> matrices, the above may not be true, and inverse and determinant can be very useful.</p>
<p>While certain decompositions, such as <a class="el" href="classEigen_1_1PartialPivLU.html" title="LU decomposition of a matrix with partial pivoting, and related features.">PartialPivLU</a> and <a class="el" href="classEigen_1_1FullPivLU.html" title="LU decomposition of a matrix with complete pivoting, and related features.">FullPivLU</a>, offer <a class="el" href="namespaceEigen.html#ae9de9064c3b832ee804c0e0957e80334">inverse()</a> and determinant() methods, you can also call <a class="el" href="namespaceEigen.html#ae9de9064c3b832ee804c0e0957e80334">inverse()</a> and determinant() directly on a matrix. If your matrix is of a very small fixed size (at most 4x4) this allows <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> to avoid performing a LU decomposition, and instead use formulas that are more efficient on such small matrices.</p>
<p>Here is an example: </p><table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   Matrix3f A;</div>
<div class="line">   A &lt;&lt; 1, 2, 1,</div>
<div class="line">        2, 1, 0,</div>
<div class="line">        -1, 1, 2;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;The determinant of A is &quot;</span> &lt;&lt; A.determinant() &lt;&lt; endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;The inverse of A is:\n&quot;</span> &lt;&lt; A.inverse() &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix A:
 1  2  1
 2  1  0
-1  1  2
The determinant of A is -3
The inverse of A is:
-0.667      1  0.333
  1.33     -1 -0.667
    -1      1      1
</pre>   </td></tr>
</table>
<h1><a class="anchor" id="TutorialLinAlgSeparateComputation"></a>
Separating the computation from the construction</h1>
<p>In the above examples, the decomposition was computed at the same time that the decomposition object was constructed. There are however situations where you might want to separate these two things, for example if you don't know, at the time of the construction, the matrix that you will want to decompose; or if you want to reuse an existing decomposition object.</p>
<p>What makes this possible is that: </p><ul>
<li>all decompositions have a default constructor, </li>
<li>all decompositions have a compute(matrix) method that does the computation, and that may be called again on an already-computed decomposition, reinitializing it.</li>
</ul>
<p>For example:</p>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   Matrix2f A, b;</div>
<div class="line">   LLT&lt;Matrix2f&gt; llt;</div>
<div class="line">   A &lt;&lt; 2, -1, -1, 3;</div>
<div class="line">   b &lt;&lt; 1, 2, 3, 1;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is the right hand side b:\n&quot;</span> &lt;&lt; b &lt;&lt; endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Computing LLT decomposition...&quot;</span> &lt;&lt; endl;</div>
<div class="line">   llt.compute(A);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;The solution is:\n&quot;</span> &lt;&lt; llt.solve(b) &lt;&lt; endl;</div>
<div class="line">   A(1,1)++;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;The matrix A is now:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Computing LLT decomposition...&quot;</span> &lt;&lt; endl;</div>
<div class="line">   llt.compute(A);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;The solution is now:\n&quot;</span> &lt;&lt; llt.solve(b) &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix A:
 2 -1
-1  3
Here is the right hand side b:
1 2
3 1
Computing LLT decomposition...
The solution is:
1.2 1.4
1.4 0.8
The matrix A is now:
 2 -1
-1  4
Computing LLT decomposition...
The solution is now:
    1  1.29
    1 0.571
</pre>   </td></tr>
</table>
<p>Finally, you can tell the decomposition constructor to preallocate storage for decomposing matrices of a given size, so that when you subsequently decompose such matrices, no dynamic memory allocation is performed (of course, if you are using fixed-size matrices, no dynamic memory allocation happens at all). This is done by just passing the size to the decomposition constructor, as in this example: </p><div class="fragment"><div class="line">HouseholderQR&lt;MatrixXf&gt; qr(50,50);</div>
<div class="line">MatrixXf A = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">MatrixXf::Random</a>(50,50);</div>
<div class="line">qr.compute(A); <span class="comment">// no dynamic memory allocation</span></div>
</div><!-- fragment --><h1><a class="anchor" id="TutorialLinAlgRankRevealing"></a>
Rank-revealing decompositions</h1>
<p>Certain decompositions are rank-revealing, i.e. are able to compute the rank of a matrix. These are typically also the decompositions that behave best in the face of a non-full-rank matrix (which in the square case means a singular matrix). On <a class="el" href="group__TopicLinearAlgebraDecompositions.html">this table</a> you can see for all our decompositions whether they are rank-revealing or not.</p>
<p>Rank-revealing decompositions offer at least a rank() method. They can also offer convenience methods such as isInvertible(), and some are also providing methods to compute the kernel (null-space) and image (column-space) of the matrix, as is the case with <a class="el" href="classEigen_1_1FullPivLU.html" title="LU decomposition of a matrix with complete pivoting, and related features.">FullPivLU</a>:</p>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   Matrix3f A;</div>
<div class="line">   A &lt;&lt; 1, 2, 5,</div>
<div class="line">        2, 1, 4,</div>
<div class="line">        3, 0, 3;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</div>
<div class="line">   FullPivLU&lt;Matrix3f&gt; lu_decomp(A);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;The rank of A is &quot;</span> &lt;&lt; lu_decomp.rank() &lt;&lt; endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is a matrix whose columns form a basis of the null-space of A:\n&quot;</span></div>
<div class="line">        &lt;&lt; lu_decomp.kernel() &lt;&lt; endl;</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;Here is a matrix whose columns form a basis of the column-space of A:\n&quot;</span></div>
<div class="line">        &lt;&lt; lu_decomp.image(A) &lt;&lt; endl; <span class="comment">// yes, have to pass the original A</span></div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix A:
1 2 5
2 1 4
3 0 3
The rank of A is 2
Here is a matrix whose columns form a basis of the null-space of A:
 0.5
   1
-0.5
Here is a matrix whose columns form a basis of the column-space of A:
5 1
4 2
3 3
</pre>   </td></tr>
</table>
<p>Of course, any rank computation depends on the choice of an arbitrary threshold, since practically no floating-point matrix is <em>exactly</em> rank-deficient. <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> picks a sensible default threshold, which depends on the decomposition but is typically the diagonal size times machine epsilon. While this is the best default we could pick, only you know what is the right threshold for your application. You can set this by calling setThreshold() on your decomposition object before calling rank() or any other method that needs to use such a threshold. The decomposition itself, i.e. the compute() method, is independent of the threshold. You don't need to recompute the decomposition after you've changed the threshold.</p>
<table class="example">
<tr>
<th>Example:</th><th>Output: </th></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   Matrix2d A;</div>
<div class="line">   A &lt;&lt; 2, 1,</div>
<div class="line">        2, 0.9999999999;</div>
<div class="line">   FullPivLU&lt;Matrix2d&gt; lu(A);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;By default, the rank of A is found to be &quot;</span> &lt;&lt; lu.rank() &lt;&lt; endl;</div>
<div class="line">   lu.setThreshold(1e-5);</div>
<div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;With threshold 1e-5, the rank of A is found to be &quot;</span> &lt;&lt; lu.rank() &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td><pre class="fragment">By default, the rank of A is found to be 2
With threshold 1e-5, the rank of A is found to be 1
</pre>   </td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 18 2021 14:57:20 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
