<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: 混叠(Aliasing)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<!--
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better know about our user community by answering the following short survey:  <a href="https://forms.gle/wpyrxWi18ox9Z5ae9">https://forms.gle/wpyrxWi18ox9Z5ae9</a></div>
-->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.4.0 (git rev e3e74001f7c4bf95f0dde572e8a08c5b2918a3ab)</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__TopicAliasing.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">混叠(Aliasing)<div class="ingroups"><a class="el" href="group__DenseMatrixManipulation__chapter.html">稠密矩阵和数组的操作</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>在 Eigen 中，aliasing 表示这样的赋值语句：相同的 matrix（或 array 或 vector）出现在赋值操作符的左边和右边。如 <code>mat = 2 * mat;</code> or <code>mat = mat.transpose();</code> 这样的语句展示了 aliasing。第一个例子中的 aliasing 是 harmless 的，但是第二个例子中的 aliasing 会导致不被期望的结果。这个页面解释了什么是 aliasing、什么时候它是 harmful的 以及 what to do about it。</p>
<h1><a class="anchor" id="TopicAliasingExamples"></a>
Examples</h1>
<p>Here is a simple example exhibiting aliasing:</p>
<table class="example">
<tr>
<th>Example</th><th>Output </th></tr>
<tr>
<td><div class="fragment"><div class="line">MatrixXi mat(3,3); </div>
<div class="line">mat &lt;&lt; 1, 2, 3,   4, 5, 6,   7, 8, 9;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix mat:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This assignment shows the aliasing problem</span></div>
<div class="line">mat.bottomRightCorner(2,2) = mat.topLeftCorner(2,2);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;After the assignment, mat = \n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix mat:
1 2 3
4 5 6
7 8 9
After the assignment, mat = 
1 2 3
4 1 2
7 4 1
</pre> </td></tr>
</table>
<p>The output is not what one would expect. The problem is the assignment </p><div class="fragment"><div class="line">mat.bottomRightCorner(2,2) = mat.topLeftCorner(2,2);</div>
</div><!-- fragment --><p> This assignment exhibits aliasing: the coefficient <code>mat(1,1)</code> appears both in the block <code>mat.bottomRightCorner(2,2)</code> on the left-hand side of the assignment and the block <code>mat.topLeftCorner(2,2)</code> on the right-hand side. After the assignment, the (2,2) entry in the bottom right corner should have the value of <code>mat(1,1)</code> before the assignment, which is 5. However, the output shows that <code>mat(2,2)</code> is actually 1. The problem is that Eigen uses lazy evaluation (see <a class="el" href="TopicEigenExpressionTemplates.html">Expression templates in Eigen</a>) for <code>mat.topLeftCorner(2,2)</code>. The result is similar to </p><div class="fragment"><div class="line">mat(1,1) = mat(0,0);</div>
<div class="line">mat(1,2) = mat(0,1);</div>
<div class="line">mat(2,1) = mat(1,0);</div>
<div class="line">mat(2,2) = mat(1,1);</div>
</div><!-- fragment --><p> Thus, <code>mat(2,2)</code> is assigned the <em>new</em> value of <code>mat(1,1)</code> instead of the old value. The next section explains how to solve this problem by calling <a class="el" href="classEigen_1_1DenseBase.html#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval()</a>.</p>
<p>Aliasing occurs more naturally when trying to shrink a matrix. For example, the expressions <code>vec = vec.head(n)</code> and <code>mat = mat.block(i,j,r,c)</code> exhibit aliasing.</p>
<p>In general, aliasing cannot be detected at compile time: if <code>mat</code> in the first example were a bit bigger, then the blocks would not overlap, and there would be no aliasing problem. However, Eigen does detect some instances of aliasing, albeit at run time. The following example exhibiting aliasing was mentioned in <a class="el" href="group__TutorialMatrixArithmetic.html">Matrix 和 vector 算法</a> :</p>
<table class="example">
<tr>
<th>Example</th><th>Output </th></tr>
<tr>
<td><div class="fragment"><div class="line">Matrix2i a; a &lt;&lt; 1, 2, 3, 4;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">a = a.transpose(); <span class="comment">// !!! do NOT do this !!!</span></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;and the result of the aliasing effect:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix a:
1 2
3 4
and the result of the aliasing effect:
1 2
2 4
</pre> </td></tr>
</table>
<p>Again, the output shows the aliasing issue. However, by default Eigen uses a run-time assertion to detect this and exits with a message like</p>
<pre class="fragment">void Eigen::DenseBase&lt;Derived&gt;::checkTransposeAliasing(const OtherDerived&amp;) const 
[with OtherDerived = Eigen::Transpose&lt;Eigen::Matrix&lt;int, 2, 2, 0, 2, 2&gt; &gt;, Derived = Eigen::Matrix&lt;int, 2, 2, 0, 2, 2&gt;]: 
Assertion `(!internal::check_transpose_aliasing_selector&lt;Scalar,internal::blas_traits&lt;Derived&gt;::IsTransposed,OtherDerived&gt;::run(internal::extract_data(derived()), other)) 
&amp;&amp; "aliasing detected during transposition, use transposeInPlace() or evaluate the rhs into a temporary using .eval()"' failed.
</pre><p>The user can turn Eigen's run-time assertions like the one to detect this aliasing problem off by defining the EIGEN_NO_DEBUG macro, and the above program was compiled with this macro turned off in order to illustrate the aliasing problem. See <a class="el" href="TopicAssertions.html">Assertions</a> for more information about Eigen's run-time assertions.</p>
<h1><a class="anchor" id="TopicAliasingSolution"></a>
Resolving aliasing issues</h1>
<p>If you understand the cause of the aliasing issue, then it is obvious what must happen to solve it: Eigen has to evaluate the right-hand side fully into a temporary matrix/array and then assign it to the left-hand side. The function <a class="el" href="classEigen_1_1DenseBase.html#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval() </a> does precisely that.</p>
<p>For example, here is the corrected version of the first example above:</p>
<table class="example">
<tr>
<th>Example</th><th>Output </th></tr>
<tr>
<td><div class="fragment"><div class="line">MatrixXi mat(3,3); </div>
<div class="line">mat &lt;&lt; 1, 2, 3,   4, 5, 6,   7, 8, 9;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix mat:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The eval() solves the aliasing problem</span></div>
<div class="line">mat.bottomRightCorner(2,2) = mat.topLeftCorner(2,2).eval();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;After the assignment, mat = \n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix mat:
1 2 3
4 5 6
7 8 9
After the assignment, mat = 
1 2 3
4 1 2
7 4 5
</pre> </td></tr>
</table>
<p>Now, <code>mat(2,2)</code> equals 5 after the assignment, as it should be.</p>
<p>The same solution also works for the second example, with the transpose: simply replace the line <code>a = a.transpose();</code> with <code>a = a.transpose().eval();</code>. However, in this common case there is a better solution. Eigen provides the special-purpose function <a class="el" href="classEigen_1_1DenseBase.html#ac501bd942994af7a95d95bee7a16ad2a">transposeInPlace() </a> which replaces a matrix by its transpose. This is shown below:</p>
<table class="example">
<tr>
<th>Example</th><th>Output </th></tr>
<tr>
<td><div class="fragment"><div class="line">MatrixXf a(2,3); a &lt;&lt; 1, 2, 3, 4, 5, 6;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the initial matrix a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">a.transposeInPlace();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;and after being transposed:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the initial matrix a:
1 2 3
4 5 6
and after being transposed:
1 4
2 5
3 6
</pre> </td></tr>
</table>
<p>If an xxxInPlace() function is available, then it is best to use it, because it indicates more clearly what you are doing. This may also allow Eigen to optimize more aggressively. These are some of the xxxInPlace() functions provided:</p>
<table class="manual">
<tr>
<th>Original function</th><th>In-place function </th></tr>
<tr>
<td><a class="el" href="classEigen_1_1MatrixBase.html#afacca1f88da57e5cd87dd07c8ff926bb">MatrixBase::adjoint()</a>  </td><td><a class="el" href="classEigen_1_1MatrixBase.html#a51c5982c1f64e45a939515b701fa6f4a">MatrixBase::adjointInPlace()</a>   </td></tr>
<tr class="alt">
<td><a class="el" href="classEigen_1_1DenseBase.html#a38ea394036d8b096abf322469c80198f">DenseBase::reverse()</a>  </td><td><a class="el" href="classEigen_1_1DenseBase.html#adb8045155ea45f7961fc2a5170e1d921">DenseBase::reverseInPlace()</a>   </td></tr>
<tr>
<td><a class="el" href="classEigen_1_1LDLT.html#aa257dd7a8acf8b347d5a22a13d6ca3e1">LDLT::solve()</a>  </td><td>LDLT::solveInPlace()   </td></tr>
<tr class="alt">
<td><a class="el" href="classEigen_1_1LLT.html#a3738bb3ce6f9b837a2beb432b937499f">LLT::solve()</a>  </td><td>LLT::solveInPlace()   </td></tr>
<tr>
<td>TriangularView::solve()  </td><td>TriangularView::solveInPlace()   </td></tr>
<tr class="alt">
<td><a class="el" href="classEigen_1_1DenseBase.html#ac8952c19644a4ac7e41bea45c19b909c">DenseBase::transpose()</a>  </td><td><a class="el" href="classEigen_1_1DenseBase.html#ac501bd942994af7a95d95bee7a16ad2a">DenseBase::transposeInPlace()</a>   </td></tr>
</table>
<p>In the special case where a matrix or vector is shrunk using an expression like <code>vec = vec.head(n)</code>, you can use <a class="el" href="classEigen_1_1PlainObjectBase.html#a712c25be1652e5a64a00f28c8ed11462">conservativeResize() </a>.</p>
<h1><a class="anchor" id="TopicAliasingCwise"></a>
Aliasing and component-wise operations</h1>
<p>As explained above, it may be dangerous if the same matrix or array occurs on both the left-hand side and the right-hand side of an assignment operator, and it is then often necessary to evaluate the right-hand side explicitly. However, applying component-wise operations (such as matrix addition, scalar multiplication and array multiplication) is safe.</p>
<p>The following example has only component-wise operations. Thus, there is no need for <a class="el" href="classEigen_1_1DenseBase.html#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval() </a> even though the same matrix appears on both sides of the assignments.</p>
<table class="example">
<tr>
<th>Example</th><th>Output </th></tr>
<tr>
<td><div class="fragment"><div class="line">MatrixXf mat(2,2); </div>
<div class="line">mat &lt;&lt; 1, 2,  4, 7;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix mat:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">mat = 2 * mat;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;After &#39;mat = 2 * mat&#39;, mat = \n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">mat = mat - <a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXf::Identity</a>(2,2);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;After the subtraction, it becomes\n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">ArrayXXf arr = mat;</div>
<div class="line">arr = arr.square();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;After squaring, it becomes\n&quot;</span> &lt;&lt; arr &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Combining all operations in one statement:</span></div>
<div class="line">mat &lt;&lt; 1, 2,  4, 7;</div>
<div class="line">mat = (2 * mat - <a class="code" href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXf::Identity</a>(2,2)).array().square();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Doing everything at once yields\n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1MatrixBase_html_a98bb9a0f705c6dfde85b0bfff31bf88f"><div class="ttname"><a href="classEigen_1_1MatrixBase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">Eigen::MatrixBase::Identity</a></div><div class="ttdeci">static const IdentityReturnType Identity()</div><div class="ttdef"><b>Definition:</b> CwiseNullaryOp.h:799</div></div>
</div><!-- fragment -->  </td><td><pre class="fragment">Here is the matrix mat:
1 2
4 7

After 'mat = 2 * mat', mat = 
 2  4
 8 14

After the subtraction, it becomes
 1  4
 8 13

After squaring, it becomes
  1  16
 64 169

Doing everything at once yields
  1  16
 64 169

</pre> </td></tr>
</table>
<p>In general, an assignment is safe if the (i,j) entry of the expression on the right-hand side depends only on the (i,j) entry of the matrix or array on the left-hand side and not on any other entries. In that case it is not necessary to evaluate the right-hand side explicitly.</p>
<h1><a class="anchor" id="TopicAliasingMatrixMult"></a>
Aliasing and matrix multiplication</h1>
<p><a class="el" href="classEigen_1_1Matrix.html" title="Matrix 类, also used for vectors and row-vectors.">Matrix</a> multiplication is the only operation in Eigen that assumes aliasing by default, <b>under the condition that the destination matrix is not resized</b>. Thus, if <code>matA</code> is a <b>squared</b> matrix, then the statement <code>matA = matA * matA;</code> is safe. All other operations in Eigen assume that there are no aliasing problems, either because the result is assigned to a different matrix or because it is a component-wise operation.</p>
<table class="example">
<tr>
<th>Example</th><th>Output </th></tr>
<tr>
<td><div class="fragment"><div class="line">MatrixXf matA(2,2); </div>
<div class="line">matA &lt;&lt; 2, 0,  0, 2;</div>
<div class="line">matA = matA * matA;</div>
<div class="line">cout &lt;&lt; matA;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">4 0
0 4</pre> </td></tr>
</table>
<p>However, this comes at a price. When executing the expression <code>matA = matA * matA</code>, Eigen evaluates the product in a temporary matrix which is assigned to <code>matA</code> after the computation. This is fine. But Eigen does the same when the product is assigned to a different matrix (e.g., <code>matB = matA * matA</code>). In that case, it is more efficient to evaluate the product directly into <code>matB</code> instead of evaluating it first into a temporary matrix and copying that matrix to <code>matB</code>.</p>
<p>The user can indicate with the <a class="el" href="classEigen_1_1MatrixBase.html#a2c1085de7645f23f240876388457da0b">noalias()</a> function that there is no aliasing, as follows: <code>matB.noalias() = matA * matA</code>. This allows Eigen to evaluate the matrix product <code>matA * matA</code> directly into <code>matB</code>.</p>
<table class="example">
<tr>
<th>Example</th><th>Output </th></tr>
<tr>
<td><div class="fragment"><div class="line">MatrixXf matA(2,2), matB(2,2); </div>
<div class="line">matA &lt;&lt; 2, 0,  0, 2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Simple but not quite as efficient</span></div>
<div class="line">matB = matA * matA;</div>
<div class="line">cout &lt;&lt; matB &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// More complicated but also more efficient</span></div>
<div class="line">matB.noalias() = matA * matA;</div>
<div class="line">cout &lt;&lt; matB;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">4 0
0 4

4 0
0 4</pre> </td></tr>
</table>
<p>Of course, you should not use <code>noalias()</code> when there is in fact aliasing taking place. If you do, then you may get wrong results:</p>
<table class="example">
<tr>
<th>Example</th><th>Output </th></tr>
<tr>
<td><div class="fragment"><div class="line">MatrixXf matA(2,2); </div>
<div class="line">matA &lt;&lt; 2, 0,  0, 2;</div>
<div class="line">matA.noalias() = matA * matA;</div>
<div class="line">cout &lt;&lt; matA;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">4 0
0 4</pre> </td></tr>
</table>
<p>Moreover, starting in <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3, aliasing is <b>not</b> assumed if the destination matrix is resized and the product is not directly assigned to the destination. Therefore, the following example is also wrong:</p>
<table class="example">
<tr>
<th>Example</th><th>Output </th></tr>
<tr>
<td><div class="fragment"><div class="line">MatrixXf A(2,2), B(3,2);</div>
<div class="line">B &lt;&lt; 2, 0,  0, 3, 1, 1;</div>
<div class="line">A &lt;&lt; 2, 0, 0, -2;</div>
<div class="line">A = (B * A).cwiseAbs();</div>
<div class="line">cout &lt;&lt; A;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">4 0
0 6
2 2</pre> </td></tr>
</table>
<p>As for any aliasing issue, you can resolve it by explicitly evaluating the expression prior to assignment: </p><table class="example">
<tr>
<th>Example</th><th>Output </th></tr>
<tr>
<td><div class="fragment"><div class="line">MatrixXf A(2,2), B(3,2);</div>
<div class="line">B &lt;&lt; 2, 0,  0, 3, 1, 1;</div>
<div class="line">A &lt;&lt; 2, 0, 0, -2;</div>
<div class="line">A = (B * A).eval().cwiseAbs();</div>
<div class="line">cout &lt;&lt; A;</div>
</div><!-- fragment -->  </td><td><pre class="fragment">4 0
0 6
2 2</pre> </td></tr>
</table>
<h1><a class="anchor" id="TopicAliasingSummary"></a>
Summary</h1>
<p>Aliasing occurs when the same matrix or array coefficients appear both on the left- and the right-hand side of an assignment operator.</p><ul>
<li>Aliasing is harmless with coefficient-wise computations; this includes scalar multiplication and matrix or array addition.</li>
<li>When you multiply two matrices, Eigen assumes that aliasing occurs. If you know that there is no aliasing, then you can use <a class="el" href="classEigen_1_1MatrixBase.html#a2c1085de7645f23f240876388457da0b">noalias()</a>.</li>
<li>In all other situations, Eigen assumes that there is no aliasing issue and thus gives the wrong result if aliasing does in fact occur. To prevent this, you have to use <a class="el" href="classEigen_1_1DenseBase.html#aa73e57a2f0f7cfcb4ad4d55ea0b6414b">eval() </a> or one of the xxxInPlace() functions. </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 18 2021 14:57:20 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
