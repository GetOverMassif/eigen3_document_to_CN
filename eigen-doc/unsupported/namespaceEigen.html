<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen-unsupported: Eigen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<!--
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better know about our user community by answering the following short survey:  <a href="https://forms.gle/wpyrxWi18ox9Z5ae9">https://forms.gle/wpyrxWi18ox9Z5ae9</a></div>
-->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen-unsupported</a>
   &#160;<span id="projectnumber">3.4.0 (git rev e3e74001f7c4bf95f0dde572e8a08c5b2918a3ab)</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceEigen.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Eigen Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing all symbols from the Eigen library.  
<a href="namespaceEigen.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1aligned__allocator.html">aligned_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1AlignedBox.html">AlignedBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1AlignedVector3.html">AlignedVector3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vectorization friendly 3D vector.  <a href="classEigen_1_1AlignedVector3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1AMDOrdering.html">AMDOrdering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1AngleAxis.html">AngleAxis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Array.html">Array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1ArrayBase.html">ArrayBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1ArrayWrapper.html">ArrayWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1ArrayXpr.html">ArrayXpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar type replacement with automatic differentiation capability.  <a href="classEigen_1_1AutoDiffScalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1BDCSVD.html">BDCSVD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1BiCGSTAB.html">BiCGSTAB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Block.html">Block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1BlockImpl_3_01XprType_00_01BlockRows_00_01BlockCols_00_01InnerPanel_00_01Sparse_01_4.html">BlockImpl&lt; XprType, BlockRows, BlockCols, InnerPanel, Sparse &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1BlockSparseMatrix.html">BlockSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A versatile sparse matrix representation where each element is a block.  <a href="classEigen_1_1BlockSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1CholmodBase.html">CholmodBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1CholmodDecomposition.html">CholmodDecomposition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1CholmodSimplicialLDLT.html">CholmodSimplicialLDLT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1CholmodSimplicialLLT.html">CholmodSimplicialLLT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1CholmodSupernodalLLT.html">CholmodSupernodalLLT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1COLAMDOrdering.html">COLAMDOrdering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1ColPivHouseholderQR.html">ColPivHouseholderQR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1CommaInitializer.html">CommaInitializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1CompleteOrthogonalDecomposition.html">CompleteOrthogonalDecomposition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1ComplexEigenSolver.html">ComplexEigenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1ComplexSchur.html">ComplexSchur</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1ConjugateGradient.html">ConjugateGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1CwiseTernaryOp.html">CwiseTernaryOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1Dense.html">Dense</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1DenseBase.html">DenseBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectAccessors_01_4.html">DenseCoeffsBase&lt; Derived, DirectAccessors &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html">DenseCoeffsBase&lt; Derived, DirectWriteAccessors &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html">DenseCoeffsBase&lt; Derived, ReadOnlyAccessors &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html">DenseCoeffsBase&lt; Derived, WriteAccessors &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DGMRES.html">DGMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Restarted <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems.">GMRES</a> with deflation. This class implements a modification of the <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems.">GMRES</a> solver for sparse linear systems. The basis is built with modified Gram-Schmidt. At each restart, a few approximated eigenvectors corresponding to the smallest eigenvalues are used to build a preconditioner for the next cycle. This preconditioner for deflation can be combined with any other preconditioner, the <a class="elRef" href="../classEigen_1_1IncompleteLUT.html">IncompleteLUT</a> for instance. The preconditioner is applied at right of the matrix and the combination is multiplicative.  <a href="classEigen_1_1DGMRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Diagonal.html">Diagonal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1DiagonalMatrix.html">DiagonalMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1DiagonalPreconditioner.html">DiagonalPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1DiagonalWrapper.html">DiagonalWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DynamicSGroup.html">DynamicSGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic symmetry group.  <a href="classEigen_1_1DynamicSGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DynamicSparseMatrix.html">DynamicSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse matrix class designed for matrix assembly purpose.  <a href="classEigen_1_1DynamicSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1EigenBase.html">EigenBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1EigenSolver.html">EigenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rotation in a 3 dimensional space as three Euler angles.  <a href="classEigen_1_1EulerAngles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a fixed Euler rotation system.  <a href="classEigen_1_1EulerSystem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1FullPivHouseholderQR.html">FullPivHouseholderQR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1FullPivLU.html">FullPivLU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1GeneralizedEigenSolver.html">GeneralizedEigenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1GeneralizedSelfAdjointEigenSolver.html">GeneralizedSelfAdjointEigenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1GMRES.html">GMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems.">GMRES</a> solver for sparse square problems.  <a href="classEigen_1_1GMRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1HessenbergDecomposition.html">HessenbergDecomposition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Homogeneous.html">Homogeneous</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1HouseholderQR.html">HouseholderQR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1HouseholderSequence.html">HouseholderSequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1HybridNonLinearSolver.html">HybridNonLinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a zero of a system of n nonlinear functions in n variables by a modification of the Powell hybrid method ("dogleg").  <a href="classEigen_1_1HybridNonLinearSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Hyperplane.html">Hyperplane</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1IdentityPreconditioner.html">IdentityPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1IDRS.html">IDRS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Induced Dimension Reduction method (IDR(s)) is a short-recurrences Krylov method for sparse square problems.  <a href="classEigen_1_1IDRS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1IncompleteCholesky.html">IncompleteCholesky</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1IncompleteLUT.html">IncompleteLUT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1IndexedView.html">IndexedView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1InnerStride.html">InnerStride</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Inverse.html">Inverse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1IOFormat.html">IOFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1IterationController.html">IterationController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the iterations of the iterative solvers.  <a href="classEigen_1_1IterationController.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1IterativeSolverBase.html">IterativeSolverBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1IterScaling.html">IterScaling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterative scaling algorithm to equilibrate rows and column norms in matrices  <a href="classEigen_1_1IterScaling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1JacobiRotation.html">JacobiRotation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1JacobiSVD.html">JacobiSVD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1KdBVH.html">KdBVH</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple bounding volume hierarchy based on <a class="elRef" href="../classEigen_1_1AlignedBox.html">AlignedBox</a>.  <a href="classEigen_1_1KdBVH.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1KroneckerProduct.html">KroneckerProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker tensor product helper class for dense matrices.  <a href="classEigen_1_1KroneckerProduct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1KroneckerProductBase.html">KroneckerProductBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of dense and sparse Kronecker product.  <a href="classEigen_1_1KroneckerProductBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1KroneckerProductSparse.html">KroneckerProductSparse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker tensor product helper class for sparse matrices.  <a href="classEigen_1_1KroneckerProductSparse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1LDLT.html">LDLT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1LeastSquareDiagonalPreconditioner.html">LeastSquareDiagonalPreconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1LeastSquaresConjugateGradient.html">LeastSquaresConjugateGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1LevenbergMarquardt.html">LevenbergMarquardt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs non linear optimization over a non-linear function, using a variant of the Levenberg Marquardt algorithm.  <a href="classEigen_1_1LevenbergMarquardt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1LLT.html">LLT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Map.html">Map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Map_3_01const_01Quaternion_3_01__Scalar_01_4_00_01__Options_01_4.html">Map&lt; const Quaternion&lt; _Scalar &gt;, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Map_3_01Quaternion_3_01__Scalar_01_4_00_01__Options_01_4.html">Map&lt; Quaternion&lt; _Scalar &gt;, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Map_3_01SparseMatrixType_01_4.html">Map&lt; SparseMatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1MapBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html">MapBase&lt; Derived, ReadOnlyAccessors &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1MapBase_3_01Derived_00_01WriteAccessors_01_4.html">MapBase&lt; Derived, WriteAccessors &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1MappedSparseMatrix.html">MappedSparseMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Matrix.html">Matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1MatrixBase.html">MatrixBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixComplexPowerReturnValue.html">MatrixComplexPowerReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix (expression).  <a href="classEigen_1_1MatrixComplexPowerReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1MatrixExponentialReturnValue.html">MatrixExponentialReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix exponential of some matrix (expression).  <a href="structEigen_1_1MatrixExponentialReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix function of some matrix (expression).  <a href="classEigen_1_1MatrixFunctionReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixLogarithmReturnValue.html">MatrixLogarithmReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix logarithm of some matrix (expression).  <a href="classEigen_1_1MatrixLogarithmReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixMarketIterator.html">MatrixMarketIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to browse matrices from a specified folder.  <a href="classEigen_1_1MatrixMarketIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPower.html">MatrixPower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix powers.  <a href="classEigen_1_1MatrixPower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerAtomic.html">MatrixPowerAtomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix powers.  <a href="classEigen_1_1MatrixPowerAtomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerParenthesesReturnValue.html">MatrixPowerParenthesesReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix.  <a href="classEigen_1_1MatrixPowerParenthesesReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerReturnValue.html">MatrixPowerReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix (expression).  <a href="classEigen_1_1MatrixPowerReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRootReturnValue.html">MatrixSquareRootReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix square root of some matrix (expression).  <a href="classEigen_1_1MatrixSquareRootReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1MatrixWrapper.html">MatrixWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1MatrixXpr.html">MatrixXpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MaxSizeVector.html">MaxSizeVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classEigen_1_1MaxSizeVector.html" title="The MaxSizeVector class.">MaxSizeVector</a> class.  <a href="classEigen_1_1MaxSizeVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1MetisOrdering.html">MetisOrdering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MINRES.html">MINRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minimal residual solver for sparse symmetric problems.  <a href="classEigen_1_1MINRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1NaturalOrdering.html">NaturalOrdering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1NestByValue.html">NestByValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1NoAlias.html">NoAlias</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1NumericalDiff.html">NumericalDiff</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1NumTraits.html">NumTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01mpfr_1_1mpreal_01_4.html">NumTraits&lt; mpfr::mpreal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1OuterStride.html">OuterStride</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1ParametrizedLine.html">ParametrizedLine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PardisoLDLT.html">PardisoLDLT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PardisoLLT.html">PardisoLLT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PardisoLU.html">PardisoLU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PartialPivLU.html">PartialPivLU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PartialReduxExpr.html">PartialReduxExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PastixLDLT.html">PastixLDLT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PastixLLT.html">PastixLLT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PastixLU.html">PastixLU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PermutationBase.html">PermutationBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PermutationMatrix.html">PermutationMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1PermutationStorage.html">PermutationStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PermutationWrapper.html">PermutationWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1PlainObjectBase.html">PlainObjectBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PolynomialSolver.html">PolynomialSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polynomial solver.  <a href="classEigen_1_1PolynomialSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PolynomialSolverBase.html">PolynomialSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined to be inherited by polynomial solvers: it provides convenient methods such as.  <a href="classEigen_1_1PolynomialSolverBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Product.html">Product</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Quaternion.html">Quaternion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1QuaternionBase.html">QuaternionBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1RandomSetter.html">RandomSetter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classEigen_1_1RandomSetter.html" title="The RandomSetter is a wrapper object allowing to set/update a sparse matrix with random access.">RandomSetter</a> is a wrapper object allowing to set/update a sparse matrix with random access.  <a href="classEigen_1_1RandomSetter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1RealQZ.html">RealQZ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1RealSchur.html">RealSchur</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Ref.html">Ref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Ref_3_01SparseMatrixType_00_01Options_01_4.html">Ref&lt; SparseMatrixType, Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Ref_3_01SparseVectorType_01_4.html">Ref&lt; SparseVectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Replicate.html">Replicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Reshaped.html">Reshaped</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Reverse.html">Reverse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Rotation2D.html">Rotation2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1RotationBase.html">RotationBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1ScalarBinaryOpTraits.html">ScalarBinaryOpTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Select.html">Select</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SelfAdjointEigenSolver.html">SelfAdjointEigenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SelfAdjointView.html">SelfAdjointView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SGroup.html">SGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetry group, initialized from template arguments.  <a href="classEigen_1_1SGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SimplicialCholesky.html">SimplicialCholesky</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SimplicialCholeskyBase.html">SimplicialCholeskyBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SimplicialLDLT.html">SimplicialLDLT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SimplicialLLT.html">SimplicialLLT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineInplaceLU.html">SkylineInplaceLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace LU decomposition of a skyline matrix and associated features.  <a href="classEigen_1_1SkylineInplaceLU.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineMatrix.html">SkylineMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main skyline matrix class.  <a href="classEigen_1_1SkylineMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineMatrixBase.html">SkylineMatrixBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of any skyline matrices or skyline expressions.  <a href="classEigen_1_1SkylineMatrixBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineStorage.html">SkylineStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Solve.html">Solve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SolverBase.html">SolverBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1SolverStorage.html">SolverStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SolveWithGuess.html">SolveWithGuess</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1Sparse.html">Sparse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SparseCompressedBase.html">SparseCompressedBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SparseLU.html">SparseLU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SparseMapBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html">SparseMapBase&lt; Derived, ReadOnlyAccessors &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SparseMapBase_3_01Derived_00_01WriteAccessors_01_4.html">SparseMapBase&lt; Derived, WriteAccessors &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SparseMatrix.html">SparseMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SparseQR.html">SparseQR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SparseSelfAdjointView.html">SparseSelfAdjointView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SparseSolverBase.html">SparseSolverBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SparseVector.html">SparseVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SparseView.html">SparseView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Spline.html">Spline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing multi-dimensional spline curves.  <a href="classEigen_1_1Spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SplineFitting.html">SplineFitting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Spline.html" title="A class representing multi-dimensional spline curves.">Spline</a> fitting methods.  <a href="structEigen_1_1SplineFitting.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01__DerivativeOrder_01_4.html">SplineTraits&lt; Spline&lt; _Scalar, _Dim, _Degree &gt;, _DerivativeOrder &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time attributes of the <a class="el" href="classEigen_1_1Spline.html" title="A class representing multi-dimensional spline curves.">Spline</a> class for fixed degree.  <a href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01__DerivativeOrder_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01Dynamic_01_4.html">SplineTraits&lt; Spline&lt; _Scalar, _Dim, _Degree &gt;, Dynamic &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time attributes of the <a class="el" href="classEigen_1_1Spline.html" title="A class representing multi-dimensional spline curves.">Spline</a> class for Dynamic degree.  <a href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01Dynamic_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SPQR.html">SPQR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1StaticSGroup.html">StaticSGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static symmetry group.  <a href="classEigen_1_1StaticSGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1StdMapTraits.html">StdMapTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Stride.html">Stride</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SuperILU.html">SuperILU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SuperLU.html">SuperLU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SuperLUBase.html">SuperLUBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1SVDBase.html">SVDBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tensor class.  <a href="classEigen_1_1Tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorAsyncDevice.html">TensorAsyncDevice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression providing an operator = that will evaluate its argument asynchronously on the specified device. Currently only ThreadPoolDevice implements proper asynchronous execution, while the default and GPU devices just run the expression synchronously and call m_done() on completion..  <a href="classEigen_1_1TensorAsyncDevice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorBase.html">TensorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tensor base class.  <a href="classEigen_1_1TensorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorConcatenationOp.html">TensorConcatenationOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Tensor.html" title="The tensor class.">Tensor</a> concatenation class.  <a href="classEigen_1_1TensorConcatenationOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorConversionOp.html">TensorConversionOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Tensor.html" title="The tensor class.">Tensor</a> conversion class. This class makes it possible to vectorize type casting operations when the number of scalars per packet in the source and the destination type differ.  <a href="classEigen_1_1TensorConversionOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorCustomBinaryOp.html">TensorCustomBinaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Tensor.html" title="The tensor class.">Tensor</a> custom class.  <a href="classEigen_1_1TensorCustomBinaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorCustomUnaryOp.html">TensorCustomUnaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Tensor.html" title="The tensor class.">Tensor</a> custom class.  <a href="classEigen_1_1TensorCustomUnaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorDevice.html">TensorDevice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression providing an operator = that will evaluate its argument on the specified computing 'device' (GPU, thread pool, ...)  <a href="classEigen_1_1TensorDevice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1TensorEvaluator.html">TensorEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cost model used to limit the number of threads used for evaluating tensor expression.  <a href="structEigen_1_1TensorEvaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorFixedSize.html">TensorFixedSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fixed sized version of the tensor class.  <a href="classEigen_1_1TensorFixedSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorGeneratorOp.html">TensorGeneratorOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Tensor.html" title="The tensor class.">Tensor</a> generator class.  <a href="classEigen_1_1TensorGeneratorOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorMap.html">TensorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor expression mapping an existing array of data.  <a href="classEigen_1_1TensorMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorRef.html">TensorRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a tensor expression The expression will be evaluated lazily (as much as possible).  <a href="classEigen_1_1TensorRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Transform.html">Transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Translation.html">Translation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Transpose.html">Transpose</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Transpositions.html">Transpositions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../structEigen_1_1TranspositionsStorage.html">TranspositionsStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1TriangularBase.html">TriangularBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1TriangularView.html">TriangularView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1TriangularViewImpl_3_01__MatrixType_00_01__Mode_00_01Dense_01_4.html">TriangularViewImpl&lt; _MatrixType, _Mode, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1TriangularViewImpl_3_01MatrixType_00_01Mode_00_01Sparse_01_4.html">TriangularViewImpl&lt; MatrixType, Mode, Sparse &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Tridiagonalization.html">Tridiagonalization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1Triplet.html">Triplet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1UmfPackLU.html">UmfPackLU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1UniformScaling.html">UniformScaling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1VectorBlock.html">VectorBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1VectorwiseOp.html">VectorwiseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="../classEigen_1_1WithFormat.html">WithFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa04df76fa4fc7d93538c28bbbd838507"><td class="memItemLeft" align="right" valign="top"><a id="aa04df76fa4fc7d93538c28bbbd838507"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#aa04df76fa4fc7d93538c28bbbd838507">Spline2d</a></td></tr>
<tr class="memdesc:aa04df76fa4fc7d93538c28bbbd838507"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D double B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:aa04df76fa4fc7d93538c28bbbd838507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1709ceddcb1e899317ac4bdb9682807f"><td class="memItemLeft" align="right" valign="top"><a id="a1709ceddcb1e899317ac4bdb9682807f"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; float, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a1709ceddcb1e899317ac4bdb9682807f">Spline2f</a></td></tr>
<tr class="memdesc:a1709ceddcb1e899317ac4bdb9682807f"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D float B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:a1709ceddcb1e899317ac4bdb9682807f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dfede40d5b8f3b2443ff20d891f455"><td class="memItemLeft" align="right" valign="top"><a id="a34dfede40d5b8f3b2443ff20d891f455"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a34dfede40d5b8f3b2443ff20d891f455">Spline3d</a></td></tr>
<tr class="memdesc:a34dfede40d5b8f3b2443ff20d891f455"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D double B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:a34dfede40d5b8f3b2443ff20d891f455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612e989f65acc6abc1593909f901e455"><td class="memItemLeft" align="right" valign="top"><a id="a612e989f65acc6abc1593909f901e455"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a612e989f65acc6abc1593909f901e455">Spline3f</a></td></tr>
<tr class="memdesc:a612e989f65acc6abc1593909f901e455"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D float B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:a612e989f65acc6abc1593909f901e455"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae614aa7cdd687fb5c421a54f2ce5c361"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gae614aa7cdd687fb5c421a54f2ce5c361">EulerAxis</a> { <br />
&#160;&#160;<a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a>
, <br />
&#160;&#160;<a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a>
, <br />
&#160;&#160;<a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a>
<br />
 }</td></tr>
<tr class="memdesc:gae614aa7cdd687fb5c421a54f2ce5c361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a fixed signed rotation axis for EulerSystem.  <a href="group__EulerAngles__Module.html#gae614aa7cdd687fb5c421a54f2ce5c361">More...</a><br /></td></tr>
<tr class="separator:gae614aa7cdd687fb5c421a54f2ce5c361"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab0c429bb38ce58964b561fb9d6c9377a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ab0c429bb38ce58964b561fb9d6c9377a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ab0c429bb38ce58964b561fb9d6c9377a">bessel_i0</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:ab0c429bb38ce58964b561fb9d6c9377a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef13ab56dea757bfb7bd3e220ac478d5"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aef13ab56dea757bfb7bd3e220ac478d5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0e_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#aef13ab56dea757bfb7bd3e220ac478d5">bessel_i0e</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:aef13ab56dea757bfb7bd3e220ac478d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35e1cabdc81f3783219186a7e658a2b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae35e1cabdc81f3783219186a7e658a2b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ae35e1cabdc81f3783219186a7e658a2b">bessel_i1</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:ae35e1cabdc81f3783219186a7e658a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52c524c4108c6265e9543468da42e28"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae52c524c4108c6265e9543468da42e28"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1e_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ae52c524c4108c6265e9543468da42e28">bessel_i1e</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:ae52c524c4108c6265e9543468da42e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65acfc33a2b6140a09af67e45928e037"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a65acfc33a2b6140a09af67e45928e037"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j0_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a65acfc33a2b6140a09af67e45928e037">bessel_j0</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a65acfc33a2b6140a09af67e45928e037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4079ddbfe44e3a865cdb600353f371ab"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4079ddbfe44e3a865cdb600353f371ab"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j1_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a4079ddbfe44e3a865cdb600353f371ab">bessel_j1</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a4079ddbfe44e3a865cdb600353f371ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4664123a5ae23d981410d7dc5cd86970"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4664123a5ae23d981410d7dc5cd86970"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a4664123a5ae23d981410d7dc5cd86970">bessel_k0</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a4664123a5ae23d981410d7dc5cd86970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc57448af6eda4fa72f34be7cc72da5"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9cc57448af6eda4fa72f34be7cc72da5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0e_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a9cc57448af6eda4fa72f34be7cc72da5">bessel_k0e</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a9cc57448af6eda4fa72f34be7cc72da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e76fa84ed24785bf32665a48157bf1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a76e76fa84ed24785bf32665a48157bf1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a76e76fa84ed24785bf32665a48157bf1">bessel_k1</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a76e76fa84ed24785bf32665a48157bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e044c2baa913adea597c4d497a3315"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af9e044c2baa913adea597c4d497a3315"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1e_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#af9e044c2baa913adea597c4d497a3315">bessel_k1e</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:af9e044c2baa913adea597c4d497a3315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0c42bfd8d5b4169a542206b460b2d0"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aad0c42bfd8d5b4169a542206b460b2d0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y0_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#aad0c42bfd8d5b4169a542206b460b2d0">bessel_y0</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:aad0c42bfd8d5b4169a542206b460b2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d76185793d52703fa01d83d5b46615"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a60d76185793d52703fa01d83d5b46615"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y1_op&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a60d76185793d52703fa01d83d5b46615">bessel_y1</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a60d76185793d52703fa01d83d5b46615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7e9b581a1fc3ca3c8aff6a0a69f523"><td class="memTemplParams" colspan="2">template&lt;typename ADerived , typename BDerived , typename XDerived &gt; </td></tr>
<tr class="memitem:a6d7e9b581a1fc3ca3c8aff6a0a69f523"><td class="memTemplItemLeft" align="right" valign="top">const TensorCwiseTernaryOp&lt; internal::scalar_betainc_op&lt; typename XDerived::Scalar &gt;, const ADerived, const BDerived, const XDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a6d7e9b581a1fc3ca3c8aff6a0a69f523">betainc</a> (const ADerived &amp;a, const BDerived &amp;b, const XDerived &amp;x)</td></tr>
<tr class="separator:a6d7e9b581a1fc3ca3c8aff6a0a69f523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58db11132cd34e57ad819f3e77ff60c"><td class="memTemplParams" colspan="2">template&lt;typename ArgADerived , typename ArgBDerived , typename ArgXDerived &gt; </td></tr>
<tr class="memitem:ac58db11132cd34e57ad819f3e77ff60c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseTernaryOp.html">Eigen::CwiseTernaryOp</a>&lt; Eigen::internal::scalar_betainc_op&lt; typename ArgXDerived::Scalar &gt;, const ArgADerived, const ArgBDerived, const ArgXDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ac58db11132cd34e57ad819f3e77ff60c">betainc</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ArgADerived &gt; &amp;a, const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ArgBDerived &gt; &amp;b, const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ArgXDerived &gt; &amp;x)</td></tr>
<tr class="separator:ac58db11132cd34e57ad819f3e77ff60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d8e283f082c972338f3fc4f644b2a9"><td class="memTemplParams" colspan="2">template&lt;typename BVH , typename Intersector &gt; </td></tr>
<tr class="memitem:a07d8e283f082c972338f3fc4f644b2a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a07d8e283f082c972338f3fc4f644b2a9">BVIntersect</a> (const BVH &amp;tree, Intersector &amp;intersector)</td></tr>
<tr class="separator:a07d8e283f082c972338f3fc4f644b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memTemplParams" colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Intersector &gt; </td></tr>
<tr class="memitem:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ac3b8047a3ee05b5e6fec4668197a9a43">BVIntersect</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Intersector &amp;intersector)</td></tr>
<tr class="separator:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe73ac1482eacab0e18ee32c25508e"><td class="memTemplParams" colspan="2">template&lt;typename BVH , typename Minimizer &gt; </td></tr>
<tr class="memitem:adcbe73ac1482eacab0e18ee32c25508e"><td class="memTemplItemLeft" align="right" valign="top">Minimizer::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#adcbe73ac1482eacab0e18ee32c25508e">BVMinimize</a> (const BVH &amp;tree, Minimizer &amp;minimizer)</td></tr>
<tr class="separator:adcbe73ac1482eacab0e18ee32c25508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f6adc8b195c94a83c35de6a842556"><td class="memTemplParams" colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Minimizer &gt; </td></tr>
<tr class="memitem:a915f6adc8b195c94a83c35de6a842556"><td class="memTemplItemLeft" align="right" valign="top">Minimizer::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a915f6adc8b195c94a83c35de6a842556">BVMinimize</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Minimizer &amp;minimizer)</td></tr>
<tr class="separator:a915f6adc8b195c94a83c35de6a842556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga375e3ea1f370fb76dfe0f43a89b95926"><td class="memTemplParams" colspan="2">template&lt;typename Polynomial &gt; </td></tr>
<tr class="memitem:ga375e3ea1f370fb76dfe0f43a89b95926"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../structEigen_1_1NumTraits.html">NumTraits</a>&lt; typename Polynomial::Scalar &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials__Module.html#ga375e3ea1f370fb76dfe0f43a89b95926">cauchy_max_bound</a> (const Polynomial &amp;poly)</td></tr>
<tr class="separator:ga375e3ea1f370fb76dfe0f43a89b95926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab076afbdba0e9298a541cc4e8cc7506b"><td class="memTemplParams" colspan="2">template&lt;typename Polynomial &gt; </td></tr>
<tr class="memitem:gab076afbdba0e9298a541cc4e8cc7506b"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../structEigen_1_1NumTraits.html">NumTraits</a>&lt; typename Polynomial::Scalar &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials__Module.html#gab076afbdba0e9298a541cc4e8cc7506b">cauchy_min_bound</a> (const Polynomial &amp;poly)</td></tr>
<tr class="separator:gab076afbdba0e9298a541cc4e8cc7506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4cbde5d98411405871accf877552d2"><td class="memTemplParams" colspan="2">template&lt;typename PointArrayType , typename KnotVectorType &gt; </td></tr>
<tr class="memitem:ga1b4cbde5d98411405871accf877552d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Splines__Module.html#ga1b4cbde5d98411405871accf877552d2">ChordLengths</a> (const PointArrayType &amp;pts, KnotVectorType &amp;chord_lengths)</td></tr>
<tr class="memdesc:ga1b4cbde5d98411405871accf877552d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes chord length parameters which are required for spline interpolation.  <a href="group__Splines__Module.html#ga1b4cbde5d98411405871accf877552d2">More...</a><br /></td></tr>
<tr class="separator:ga1b4cbde5d98411405871accf877552d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd81653604859fe8e5b09552a7a800c9"><td class="memTemplParams" colspan="2">template&lt;typename AlphaDerived , typename SampleDerived &gt; </td></tr>
<tr class="memitem:afd81653604859fe8e5b09552a7a800c9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_gamma_sample_der_alpha_op&lt; typename AlphaDerived::Scalar &gt;, const AlphaDerived, const SampleDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#afd81653604859fe8e5b09552a7a800c9">gamma_sample_der_alpha</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; AlphaDerived &gt; &amp;alpha, const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; SampleDerived &gt; &amp;sample)</td></tr>
<tr class="separator:afd81653604859fe8e5b09552a7a800c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e89509c5ff1af076baea462520f231c"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr>
<tr class="memitem:a6e89509c5ff1af076baea462520f231c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_igamma_op&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a6e89509c5ff1af076baea462520f231c">igamma</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td></tr>
<tr class="separator:a6e89509c5ff1af076baea462520f231c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b09518c9ef2376690af1b346f77ff1"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr>
<tr class="memitem:ad0b09518c9ef2376690af1b346f77ff1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_igamma_der_a_op&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ad0b09518c9ef2376690af1b346f77ff1">igamma_der_a</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td></tr>
<tr class="separator:ad0b09518c9ef2376690af1b346f77ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1593c0c3f9d1673ae5980ae03e75f1"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr>
<tr class="memitem:a2b1593c0c3f9d1673ae5980ae03e75f1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_igammac_op&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a2b1593c0c3f9d1673ae5980ae03e75f1">igammac</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td></tr>
<tr class="separator:a2b1593c0c3f9d1673ae5980ae03e75f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9474da5ed68bbd9a6788a999330416d6"><td class="memTemplParams" colspan="2">template&lt;typename KnotVectorType &gt; </td></tr>
<tr class="memitem:ga9474da5ed68bbd9a6788a999330416d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Splines__Module.html#ga9474da5ed68bbd9a6788a999330416d6">KnotAveraging</a> (const KnotVectorType &amp;parameters, DenseIndex degree, KnotVectorType &amp;knots)</td></tr>
<tr class="memdesc:ga9474da5ed68bbd9a6788a999330416d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes knot averages.  <a href="group__Splines__Module.html#ga9474da5ed68bbd9a6788a999330416d6">More...</a><br /></td></tr>
<tr class="separator:ga9474da5ed68bbd9a6788a999330416d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="memTemplParams" colspan="2">template&lt;typename KnotVectorType , typename ParameterVectorType , typename IndexArray &gt; </td></tr>
<tr class="memitem:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Splines__Module.html#gae10a6f9b6ab7fb400a2526b6382c533b">KnotAveragingWithDerivatives</a> (const ParameterVectorType &amp;parameters, const unsigned int degree, const IndexArray &amp;derivativeIndices, KnotVectorType &amp;knots)</td></tr>
<tr class="memdesc:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes knot averages when derivative constraints are present. Note that this is a technical interpretation of the referenced article since the algorithm contained therein is incorrect as written.  <a href="group__Splines__Module.html#gae10a6f9b6ab7fb400a2526b6382c533b">More...</a><br /></td></tr>
<tr class="separator:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca497f43cc92bcbf6eaff64984a266cc"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:gaca497f43cc92bcbf6eaff64984a266cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1KroneckerProductSparse.html">KroneckerProductSparse</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__KroneckerProduct__Module.html#gaca497f43cc92bcbf6eaff64984a266cc">kroneckerProduct</a> (const <a class="elRef" href="../structEigen_1_1EigenBase.html">EigenBase</a>&lt; A &gt; &amp;a, const <a class="elRef" href="../structEigen_1_1EigenBase.html">EigenBase</a>&lt; B &gt; &amp;b)</td></tr>
<tr class="separator:gaca497f43cc92bcbf6eaff64984a266cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8924dffc6cee7aa1e908dc395a7a167"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:gaa8924dffc6cee7aa1e908dc395a7a167"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1KroneckerProduct.html">KroneckerProduct</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__KroneckerProduct__Module.html#gaa8924dffc6cee7aa1e908dc395a7a167">kroneckerProduct</a> (const <a class="elRef" href="../classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; A &gt; &amp;a, const <a class="elRef" href="../classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; B &gt; &amp;b)</td></tr>
<tr class="separator:gaa8924dffc6cee7aa1e908dc395a7a167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f490197e16df831683018e383e29346"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:ga2f490197e16df831683018e383e29346"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions__Module.html#ga2f490197e16df831683018e383e29346">matrix_sqrt_quasi_triangular</a> (const MatrixType &amp;<a class="elRef" href="../namespaceEigen.html#aa539408a09481d35961e11ee78793db1">arg</a>, ResultType &amp;result)</td></tr>
<tr class="memdesc:ga2f490197e16df831683018e383e29346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix square root of quasi-triangular matrix.  <a href="group__MatrixFunctions__Module.html#ga2f490197e16df831683018e383e29346">More...</a><br /></td></tr>
<tr class="separator:ga2f490197e16df831683018e383e29346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions__Module.html#gae51c91f920f6ea4a7f6f72caa1e8249f">matrix_sqrt_triangular</a> (const MatrixType &amp;<a class="elRef" href="../namespaceEigen.html#aa539408a09481d35961e11ee78793db1">arg</a>, ResultType &amp;result)</td></tr>
<tr class="memdesc:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix square root of triangular matrix.  <a href="group__MatrixFunctions__Module.html#gae51c91f920f6ea4a7f6f72caa1e8249f">More...</a><br /></td></tr>
<tr class="separator:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memTemplParams" colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr>
<tr class="memitem:gadb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials__Module.html#gadb64ffddaa9e83634e3ab0e3fd3664f5">poly_eval</a> (const Polynomials &amp;poly, const T &amp;x)</td></tr>
<tr class="separator:gadb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadbf059bc28ce1cf94c57c1454633d40"><td class="memTemplParams" colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr>
<tr class="memitem:gaadbf059bc28ce1cf94c57c1454633d40"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials__Module.html#gaadbf059bc28ce1cf94c57c1454633d40">poly_eval_horner</a> (const Polynomials &amp;poly, const T &amp;x)</td></tr>
<tr class="separator:gaadbf059bc28ce1cf94c57c1454633d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec2455c3a3bb4b0c1401b25a8480361"><td class="memTemplParams" colspan="2">template&lt;typename DerivedN , typename DerivedX &gt; </td></tr>
<tr class="memitem:a7ec2455c3a3bb4b0c1401b25a8480361"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_polygamma_op&lt; typename DerivedX::Scalar &gt;, const DerivedN, const DerivedX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a7ec2455c3a3bb4b0c1401b25a8480361">polygamma</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; DerivedN &gt; &amp;n, const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;x)</td></tr>
<tr class="separator:a7ec2455c3a3bb4b0c1401b25a8480361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc3648f7ef67db3d5d04454fc1257fd"><td class="memTemplParams" colspan="2">template&lt;typename RootVector , typename Polynomial &gt; </td></tr>
<tr class="memitem:gafbc3648f7ef67db3d5d04454fc1257fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials__Module.html#gafbc3648f7ef67db3d5d04454fc1257fd">roots_to_monicPolynomial</a> (const RootVector &amp;rv, Polynomial &amp;poly)</td></tr>
<tr class="separator:gafbc3648f7ef67db3d5d04454fc1257fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7c45ba55113cf0c89e33972f3da434"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedQ &gt; </td></tr>
<tr class="memitem:ade7c45ba55113cf0c89e33972f3da434"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_zeta_op&lt; typename DerivedX::Scalar &gt;, const DerivedX, const DerivedQ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ade7c45ba55113cf0c89e33972f3da434">zeta</a> (const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;x, const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; DerivedQ &gt; &amp;q)</td></tr>
<tr class="separator:ade7c45ba55113cf0c89e33972f3da434"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing all symbols from the Eigen library. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab0c429bb38ce58964b561fb9d6c9377a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c429bb38ce58964b561fb9d6c9377a">&#9670;&nbsp;</a></span>bessel_i0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise i0(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the modified Bessel function of the first kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i0(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_i0() </dd></dl>

</div>
</div>
<a id="aef13ab56dea757bfb7bd3e220ac478d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef13ab56dea757bfb7bd3e220ac478d5">&#9670;&nbsp;</a></span>bessel_i0e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i0e </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise i0e(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the exponentially scaled modified Bessel function of the first kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i0e(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_i0e() </dd></dl>

</div>
</div>
<a id="ae35e1cabdc81f3783219186a7e658a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35e1cabdc81f3783219186a7e658a2b">&#9670;&nbsp;</a></span>bessel_i1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise i1(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the modified Bessel function of the first kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i1(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_i1() </dd></dl>

</div>
</div>
<a id="ae52c524c4108c6265e9543468da42e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52c524c4108c6265e9543468da42e28">&#9670;&nbsp;</a></span>bessel_i1e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i1e </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise i1e(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the exponentially scaled modified Bessel function of the first kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i1e(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_i1e() </dd></dl>

</div>
</div>
<a id="a65acfc33a2b6140a09af67e45928e037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65acfc33a2b6140a09af67e45928e037">&#9670;&nbsp;</a></span>bessel_j0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_j0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise j0(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the Bessel function of the first kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of j0(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_j0() </dd></dl>

</div>
</div>
<a id="a4079ddbfe44e3a865cdb600353f371ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4079ddbfe44e3a865cdb600353f371ab">&#9670;&nbsp;</a></span>bessel_j1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_j1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise j1(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the modified Bessel function of the first kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of j1(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_j1() </dd></dl>

</div>
</div>
<a id="a4664123a5ae23d981410d7dc5cd86970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4664123a5ae23d981410d7dc5cd86970">&#9670;&nbsp;</a></span>bessel_k0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise k0(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the modified Bessel function of the second kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k0(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_k0() </dd></dl>

</div>
</div>
<a id="a9cc57448af6eda4fa72f34be7cc72da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc57448af6eda4fa72f34be7cc72da5">&#9670;&nbsp;</a></span>bessel_k0e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k0e </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise k0e(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the exponentially scaled modified Bessel function of the second kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k0e(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_k0e() </dd></dl>

</div>
</div>
<a id="a76e76fa84ed24785bf32665a48157bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e76fa84ed24785bf32665a48157bf1">&#9670;&nbsp;</a></span>bessel_k1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise k1(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the modified Bessel function of the second kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k1(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_k1() </dd></dl>

</div>
</div>
<a id="af9e044c2baa913adea597c4d497a3315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e044c2baa913adea597c4d497a3315">&#9670;&nbsp;</a></span>bessel_k1e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k1e </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise k1e(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the exponentially scaled modified Bessel function of the second kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k1e(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_k1e() </dd></dl>

</div>
</div>
<a id="aad0c42bfd8d5b4169a542206b460b2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0c42bfd8d5b4169a542206b460b2d0">&#9670;&nbsp;</a></span>bessel_y0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_y0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise y0(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the Bessel function of the second kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of y0(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_y0() </dd></dl>

</div>
</div>
<a id="a60d76185793d52703fa01d83d5b46615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d76185793d52703fa01d83d5b46615">&#9670;&nbsp;</a></span>bessel_y1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseUnaryOp.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_y1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise y1(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the Bessel function of the second kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of y1(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_y1() </dd></dl>

</div>
</div>
<a id="a6d7e9b581a1fc3ca3c8aff6a0a69f523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7e9b581a1fc3ca3c8aff6a0a69f523">&#9670;&nbsp;</a></span>betainc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ADerived , typename BDerived , typename XDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TensorCwiseTernaryOp&lt;internal::scalar_betainc_op&lt;typename XDerived::Scalar&gt;, const ADerived, const BDerived, const XDerived&gt; Eigen::betainc </td>
          <td>(</td>
          <td class="paramtype">const ADerived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BDerived &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XDerived &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise betainc(<em>x</em>, <em>a</em>, <em>b</em>) to the given tensors.</dd></dl>
<p>This function computes the regularized incomplete beta function (integral). </p>

</div>
</div>
<a id="ac58db11132cd34e57ad819f3e77ff60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58db11132cd34e57ad819f3e77ff60c">&#9670;&nbsp;</a></span>betainc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgADerived , typename ArgBDerived , typename ArgXDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseTernaryOp.html">Eigen::CwiseTernaryOp</a>&lt;Eigen::internal::scalar_betainc_op&lt;typename ArgXDerived::Scalar&gt;, const ArgADerived, const ArgBDerived, const ArgXDerived&gt; Eigen::betainc </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ArgADerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ArgBDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ArgXDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise betainc(<em>x</em>, <em>a</em>, <em>b</em>) to the given arrays.</dd></dl>
<p>This function computes the regularized incomplete beta function (integral).</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of betainc(T,T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#a6d7e9b581a1fc3ca3c8aff6a0a69f523">Eigen::betainc()</a>, <a class="elRef" href="../namespaceEigen.html#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd></dl>

</div>
</div>
<a id="a07d8e283f082c972338f3fc4f644b2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d8e283f082c972338f3fc4f644b2a9">&#9670;&nbsp;</a></span>BVIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH , typename Intersector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::BVIntersect </td>
          <td>(</td>
          <td class="paramtype">const BVH &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Intersector &amp;&#160;</td>
          <td class="paramname"><em>intersector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a BVH, runs the query encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> intersectVolume(<span class="keyword">const</span> BVH::Volume &amp;volume) <span class="comment">//returns true if volume intersects the query</span></div>
<div class="line"><span class="keywordtype">bool</span> intersectObject(<span class="keyword">const</span> BVH::Object &amp;<span class="keywordtype">object</span>) <span class="comment">//returns true if the search should terminate immediately</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac3b8047a3ee05b5e6fec4668197a9a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b8047a3ee05b5e6fec4668197a9a43">&#9670;&nbsp;</a></span>BVIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH1 , typename BVH2 , typename Intersector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::BVIntersect </td>
          <td>(</td>
          <td class="paramtype">const BVH1 &amp;&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BVH2 &amp;&#160;</td>
          <td class="paramname"><em>tree2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Intersector &amp;&#160;</td>
          <td class="paramname"><em>intersector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two BVH's, runs the query on their Cartesian product encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> intersectVolumeVolume(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Volume &amp;v2) <span class="comment">//returns true if product of volumes intersects the query</span></div>
<div class="line"><span class="keywordtype">bool</span> intersectVolumeObject(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Object &amp;o2) <span class="comment">//returns true if the volume-object product intersects the query</span></div>
<div class="line"><span class="keywordtype">bool</span> intersectObjectVolume(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Volume &amp;v2) <span class="comment">//returns true if the volume-object product intersects the query</span></div>
<div class="line"><span class="keywordtype">bool</span> intersectObjectObject(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Object &amp;o2) <span class="comment">//returns true if the search should terminate immediately</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adcbe73ac1482eacab0e18ee32c25508e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbe73ac1482eacab0e18ee32c25508e">&#9670;&nbsp;</a></span>BVMinimize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH , typename Minimizer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Minimizer::Scalar Eigen::BVMinimize </td>
          <td>(</td>
          <td class="paramtype">const BVH &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Minimizer &amp;&#160;</td>
          <td class="paramname"><em>minimizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a BVH, runs the query encapsulated by <em>minimizer</em>. </p><dl class="section return"><dt>Returns</dt><dd>the minimum value. The Minimizer type must provide the following members:<div class="fragment"><div class="line"><span class="keyword">typedef</span> Scalar <span class="comment">//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span></div>
<div class="line">Scalar minimumOnVolume(<span class="keyword">const</span> BVH::Volume &amp;volume)</div>
<div class="line">Scalar minimumOnObject(<span class="keyword">const</span> BVH::Object &amp;<span class="keywordtype">object</span>)</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a915f6adc8b195c94a83c35de6a842556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915f6adc8b195c94a83c35de6a842556">&#9670;&nbsp;</a></span>BVMinimize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH1 , typename BVH2 , typename Minimizer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Minimizer::Scalar Eigen::BVMinimize </td>
          <td>(</td>
          <td class="paramtype">const BVH1 &amp;&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BVH2 &amp;&#160;</td>
          <td class="paramname"><em>tree2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Minimizer &amp;&#160;</td>
          <td class="paramname"><em>minimizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two BVH's, runs the query on their cartesian product encapsulated by <em>minimizer</em>. </p><dl class="section return"><dt>Returns</dt><dd>the minimum value. The Minimizer type must provide the following members:<div class="fragment"><div class="line"><span class="keyword">typedef</span> Scalar <span class="comment">//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span></div>
<div class="line">Scalar minimumOnVolumeVolume(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Volume &amp;v2)</div>
<div class="line">Scalar minimumOnVolumeObject(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Object &amp;o2)</div>
<div class="line">Scalar minimumOnObjectVolume(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Volume &amp;v2)</div>
<div class="line">Scalar minimumOnObjectObject(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Object &amp;o2)</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="afd81653604859fe8e5b09552a7a800c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd81653604859fe8e5b09552a7a800c9">&#9670;&nbsp;</a></span>gamma_sample_der_alpha()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AlphaDerived , typename SampleDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_gamma_sample_der_alpha_op&lt;typename AlphaDerived::Scalar&gt;, const AlphaDerived, const SampleDerived&gt; Eigen::gamma_sample_der_alpha </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; AlphaDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; SampleDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise gamma_sample_der_alpha(<em>alpha</em>, <em>sample</em>) to the given arrays.</dd></dl>
<p>This function computes the coefficient-wise derivative of the sample of a Gamma(alpha, 1) random variable with respect to the parameter alpha.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of gamma_sample_der_alpha(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#a6e89509c5ff1af076baea462520f231c">Eigen::igamma()</a>, <a class="elRef" href="../namespaceEigen.html#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd></dl>

</div>
</div>
<a id="a6e89509c5ff1af076baea462520f231c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e89509c5ff1af076baea462520f231c">&#9670;&nbsp;</a></span>igamma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ExponentDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_igamma_op&lt;typename Derived::Scalar&gt;, const Derived, const ExponentDerived&gt; Eigen::igamma </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise igamma(<em>a</em>, <em>x</em>) to the given arrays.</dd></dl>
<p>This function computes the coefficient-wise incomplete gamma function.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igammac(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#a2b1593c0c3f9d1673ae5980ae03e75f1">Eigen::igammac()</a>, <a class="elRef" href="../namespaceEigen.html#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd></dl>

</div>
</div>
<a id="ad0b09518c9ef2376690af1b346f77ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b09518c9ef2376690af1b346f77ff1">&#9670;&nbsp;</a></span>igamma_der_a()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ExponentDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_igamma_der_a_op&lt;typename Derived::Scalar&gt;, const Derived, const ExponentDerived&gt; Eigen::igamma_der_a </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise igamma_der_a(<em>a</em>, <em>x</em>) to the given arrays.</dd></dl>
<p>This function computes the coefficient-wise derivative of the incomplete gamma function with respect to the parameter a.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igamma_der_a(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#a6e89509c5ff1af076baea462520f231c">Eigen::igamma()</a>, <a class="elRef" href="../namespaceEigen.html#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd></dl>

</div>
</div>
<a id="a2b1593c0c3f9d1673ae5980ae03e75f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1593c0c3f9d1673ae5980ae03e75f1">&#9670;&nbsp;</a></span>igammac()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ExponentDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_igammac_op&lt;typename Derived::Scalar&gt;, const Derived, const ExponentDerived&gt; Eigen::igammac </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise igammac(<em>a</em>, <em>x</em>) to the given arrays.</dd></dl>
<p>This function computes the coefficient-wise complementary incomplete gamma function.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igammac(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#a6e89509c5ff1af076baea462520f231c">Eigen::igamma()</a>, <a class="elRef" href="../namespaceEigen.html#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd></dl>

</div>
</div>
<a id="a7ec2455c3a3bb4b0c1401b25a8480361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec2455c3a3bb4b0c1401b25a8480361">&#9670;&nbsp;</a></span>polygamma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedN , typename DerivedX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_polygamma_op&lt;typename DerivedX::Scalar&gt;, const DerivedN, const DerivedX&gt; Eigen::polygamma </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise polygamma(<em>n</em>, <em>x</em>) to the given arrays.</dd></dl>
<p>It returns the <em>n</em> -th derivative of the digamma(psi) evaluated at <code>x</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of polygamma(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="elRef" href="../namespaceEigen.html#af40db84b3db19fe25fe2f77c429420e5">Eigen::digamma()</a> </dd></dl>

</div>
</div>
<a id="ade7c45ba55113cf0c89e33972f3da434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7c45ba55113cf0c89e33972f3da434">&#9670;&nbsp;</a></span>zeta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedQ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="../classEigen_1_1CwiseBinaryOp.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_zeta_op&lt;typename DerivedX::Scalar&gt;, const DerivedX, const DerivedQ&gt; Eigen::zeta </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise zeta(<em>x</em>, <em>q</em>) to the given arrays.</dd></dl>
<p>It returns the Riemann zeta function of two arguments <em>x</em> and <em>q:</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the exponent, it must be &gt; 1 </td></tr>
    <tr><td class="paramname">q</td><td>is the shift, it must be &gt; 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of zeta(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::zeta() </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li>
    <li class="footer">Generated on Wed Aug 18 2021 14:57:26 for Eigen-unsupported by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
