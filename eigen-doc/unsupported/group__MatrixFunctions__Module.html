<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen-unsupported: Matrix functions module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<!--
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better know about our user community by answering the following short survey:  <a href="https://forms.gle/wpyrxWi18ox9Z5ae9">https://forms.gle/wpyrxWi18ox9Z5ae9</a></div>
-->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen-unsupported</a>
   &#160;<span id="projectnumber">3.4.0 (git rev e3e74001f7c4bf95f0dde572e8a08c5b2918a3ab)</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__MatrixFunctions__Module.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Matrix functions module</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module aims to provide various methods for the computation of matrix functions. </p>
<p>To use this module, add </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
</div><!-- fragment --><p> at the start of your source file.</p>
<p>This module defines the following MatrixBase methods.</p><ul>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_cos">MatrixBase::cos()</a>, for computing the matrix cosine</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_cosh">MatrixBase::cosh()</a>, for computing the matrix hyperbolic cosine</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_exp">MatrixBase::exp()</a>, for computing the matrix exponential</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_log">MatrixBase::log()</a>, for computing the matrix logarithm</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_pow">MatrixBase::pow()</a>, for computing the matrix power</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_matrixfunction">MatrixBase::matrixFunction()</a>, for computing general matrix functions</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_sin">MatrixBase::sin()</a>, for computing the matrix sine</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_sinh">MatrixBase::sinh()</a>, for computing the matrix hyperbolic sine</li>
<li><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_sqrt">MatrixBase::sqrt()</a>, for computing the matrix square root</li>
</ul>
<p>These methods are the main entry points to this module.</p>
<p>Matrix functions are defined as follows. Suppose that \( f \) is an entire function (that is, a function on the complex plane that is everywhere complex differentiable). Then its Taylor series </p><p class="formulaDsp">
\[ f(0) + f&#39;(0) x + \frac{f&#39;&#39;(0)}{2} x^2 + \frac{f&#39;&#39;&#39;(0)}{3!} x^3 + \cdots \]
</p>
<p> converges to \( f(x) \). In this case, we can define the matrix function by the same series: </p><p class="formulaDsp">
\[ f(M) = f(0) + f&#39;(0) M + \frac{f&#39;&#39;(0)}{2} M^2 + \frac{f&#39;&#39;&#39;(0)}{3!} M^3 + \cdots \]
</p>
 <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixComplexPowerReturnValue.html">Eigen::MatrixComplexPowerReturnValue&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix (expression).  <a href="classEigen_1_1MatrixComplexPowerReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1MatrixExponentialReturnValue.html">Eigen::MatrixExponentialReturnValue&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix exponential of some matrix (expression).  <a href="structEigen_1_1MatrixExponentialReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixFunctionReturnValue.html">Eigen::MatrixFunctionReturnValue&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix function of some matrix (expression).  <a href="classEigen_1_1MatrixFunctionReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixLogarithmReturnValue.html">Eigen::MatrixLogarithmReturnValue&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix logarithm of some matrix (expression).  <a href="classEigen_1_1MatrixLogarithmReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPower.html">Eigen::MatrixPower&lt; MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix powers.  <a href="classEigen_1_1MatrixPower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerAtomic.html">Eigen::MatrixPowerAtomic&lt; MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix powers.  <a href="classEigen_1_1MatrixPowerAtomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerParenthesesReturnValue.html">Eigen::MatrixPowerParenthesesReturnValue&lt; MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix.  <a href="classEigen_1_1MatrixPowerParenthesesReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerReturnValue.html">Eigen::MatrixPowerReturnValue&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix (expression).  <a href="classEigen_1_1MatrixPowerReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRootReturnValue.html">Eigen::MatrixSquareRootReturnValue&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix square root of some matrix (expression).  <a href="classEigen_1_1MatrixSquareRootReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2f490197e16df831683018e383e29346"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:ga2f490197e16df831683018e383e29346"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions__Module.html#ga2f490197e16df831683018e383e29346">Eigen::matrix_sqrt_quasi_triangular</a> (const MatrixType &amp;<a class="elRef" href="../namespaceEigen.html#aa539408a09481d35961e11ee78793db1">arg</a>, ResultType &amp;result)</td></tr>
<tr class="memdesc:ga2f490197e16df831683018e383e29346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix square root of quasi-triangular matrix.  <a href="group__MatrixFunctions__Module.html#ga2f490197e16df831683018e383e29346">More...</a><br /></td></tr>
<tr class="separator:ga2f490197e16df831683018e383e29346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions__Module.html#gae51c91f920f6ea4a7f6f72caa1e8249f">Eigen::matrix_sqrt_triangular</a> (const MatrixType &amp;<a class="elRef" href="../namespaceEigen.html#aa539408a09481d35961e11ee78793db1">arg</a>, ResultType &amp;result)</td></tr>
<tr class="memdesc:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix square root of triangular matrix.  <a href="group__MatrixFunctions__Module.html#gae51c91f920f6ea4a7f6f72caa1e8249f">More...</a><br /></td></tr>
<tr class="separator:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<div class="textblock"><h1><a class="anchor" id="matrixbaseextra"></a>
MatrixBase methods defined in the MatrixFunctions module</h1>
<p>The remainder of the page documents the following MatrixBase methods which are defined in the MatrixFunctions module.</p>
<h2><a class="anchor" id="matrixbase_cos"></a>
MatrixBase::cos()</h2>
<p>Compute the matrix cosine.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::cos() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>a square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing \( \cos(M) \).</dd></dl>
<p>This function computes the matrix cosine. Use ArrayBase::cos() for computing the entry-wise cosine.</p>
<p>The implementation calls <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::cos().</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_sin">sin()</a> for an example.</dd></dl>
<h2><a class="anchor" id="matrixbase_cosh"></a>
MatrixBase::cosh()</h2>
<p>Compute the matrix hyberbolic cosine.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::cosh() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>a square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing \( \cosh(M) \)</dd></dl>
<p>This function calls <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::cosh().</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__MatrixFunctions__Module.html#matrixbase_sinh">sinh()</a> for an example.</dd></dl>
<h2><a class="anchor" id="matrixbase_exp"></a>
MatrixBase::exp()</h2>
<p>Compute the matrix exponential.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixExponentialReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::exp() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>matrix whose exponential is to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing the matrix exponential of <code>M</code>.</dd></dl>
<p>The matrix exponential of \( M \) is defined by </p><p class="formulaDsp">
\[ \exp(M) = \sum_{k=0}^\infty \frac{M^k}{k!}. \]
</p>
<p> The matrix exponential can be used to solve linear ordinary differential equations: the solution of \( y&#39; = My \) with the initial condition \( y(0) = y_0 \) is given by \( y(t) = \exp(M) y_0 \).</p>
<p>The matrix exponential is different from applying the exp function to all the entries in the matrix. Use ArrayBase::exp() if you want to do the latter.</p>
<p>The cost of the computation is approximately \( 20 n^3 \) for matrices of size \( n \). The number 20 depends weakly on the norm of the matrix.</p>
<p>The matrix exponential is computed using the scaling-and-squaring method combined with Pad&eacute; approximation. The matrix is first rescaled, then the exponential of the reduced matrix is computed approximant, and then the rescaling is undone by repeated squaring. The degree of the Pad&eacute; approximant is chosen such that the approximation error is less than the round-off error. However, errors may accumulate during the squaring phase.</p>
<p>Details of the algorithm can be found in: Nicholas J. Higham, "The
scaling and squaring method for the matrix exponential revisited," <em>SIAM J. Matrix Anal. Applic.</em>, <b>26</b>:1179&ndash;1193, 2005.</p>
<p>Example: The following program checks that </p><p class="formulaDsp">
\[ \exp \left[ \begin{array}{ccc} 0 &amp; \frac14\pi &amp; 0 \\ -\frac14\pi &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{array} \right] = \left[ \begin{array}{ccc} \frac12\sqrt2 &amp; -\frac12\sqrt2 &amp; 0 \\ \frac12\sqrt2 &amp; \frac12\sqrt2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right]. \]
</p>
<p> This corresponds to a rotation of \( \frac14\pi \) radians around the z-axis.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pi = std::acos(-1.0);</div>
<div class="line"> </div>
<div class="line">  MatrixXd A(3,3);</div>
<div class="line">  A &lt;&lt; 0,    -pi/4, 0,</div>
<div class="line">       pi/4, 0,     0,</div>
<div class="line">       0,    0,     0;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix A is:\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix exponential of A is:\n&quot;</span> &lt;&lt; A.exp() &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceEigen_html"><div class="ttname"><a href="namespaceEigen.html">Eigen</a></div><div class="ttdoc">Namespace containing all symbols from the Eigen library.</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">The matrix A is:
        0 -0.785398         0
 0.785398         0         0
        0         0         0

The matrix exponential of A is:
 0.707107 -0.707107         0
 0.707107  0.707107         0
        0         0         1

</pre><dl class="section note"><dt>Note</dt><dd><code>M</code> has to be a matrix of <code>float</code>, <code>double</code>, <code>long double</code> <code>complex&lt;float&gt;</code>, <code>complex&lt;double&gt;</code>, or <code>complex&lt;long double&gt;</code> .</dd></dl>
<h2><a class="anchor" id="matrixbase_log"></a>
MatrixBase::log()</h2>
<p>Compute the matrix logarithm.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixLogarithmReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::log() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>invertible matrix whose logarithm is to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing the matrix logarithm root of <code>M</code>.</dd></dl>
<p>The matrix logarithm of \( M \) is a matrix \( X \) such that \( \exp(X) = M \) where exp denotes the matrix exponential. As for the scalar logarithm, the equation \( \exp(X) = M \) may have multiple solutions; this function returns a matrix whose eigenvalues have imaginary part in the interval \( (-\pi,\pi] \).</p>
<p>The matrix logarithm is different from applying the log function to all the entries in the matrix. Use ArrayBase::log() if you want to do the latter.</p>
<p>In the real case, the matrix \( M \) should be invertible and it should have no eigenvalues which are real and negative (pairs of complex conjugate eigenvalues are allowed). In the complex case, it only needs to be invertible.</p>
<p>This function computes the matrix logarithm using the Schur-Parlett algorithm as implemented by MatrixBase::matrixFunction(). The logarithm of an atomic block is computed by MatrixLogarithmAtomic, which uses direct computation for 1-by-1 and 2-by-2 blocks and an inverse scaling-and-squaring algorithm for bigger blocks, with the square roots computed by MatrixBase::sqrt().</p>
<p>Details of the algorithm can be found in Section 11.6.2 of: Nicholas J. Higham, <em>Functions of Matrices: Theory and Computation</em>, SIAM 2008. ISBN 978-0-898716-46-7.</p>
<p>Example: The following program checks that </p><p class="formulaDsp">
\[ \log \left[ \begin{array}{ccc} \frac12\sqrt2 &amp; -\frac12\sqrt2 &amp; 0 \\ \frac12\sqrt2 &amp; \frac12\sqrt2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right] = \left[ \begin{array}{ccc} 0 &amp; \frac14\pi &amp; 0 \\ -\frac14\pi &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{array} \right]. \]
</p>
<p> This corresponds to a rotation of \( \frac14\pi \) radians around the z-axis. This is the inverse of the example used in the documentation of <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_exp">exp()</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> std::sqrt;</div>
<div class="line">  MatrixXd A(3,3);</div>
<div class="line">  A &lt;&lt; 0.5*<a class="codeRef" href="../namespaceEigen.html#af4f536e8ea56702e63088efb3706d1f0">sqrt</a>(2), -0.5*<a class="codeRef" href="../namespaceEigen.html#af4f536e8ea56702e63088efb3706d1f0">sqrt</a>(2), 0,</div>
<div class="line">       0.5*<a class="codeRef" href="../namespaceEigen.html#af4f536e8ea56702e63088efb3706d1f0">sqrt</a>(2),  0.5*<a class="codeRef" href="../namespaceEigen.html#af4f536e8ea56702e63088efb3706d1f0">sqrt</a>(2), 0,</div>
<div class="line">       0,            0,           1;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix A is:\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix logarithm of A is:\n&quot;</span> &lt;&lt; A.log() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceEigen_html_af4f536e8ea56702e63088efb3706d1f0"><div class="ttname"><a href="../namespaceEigen.html#af4f536e8ea56702e63088efb3706d1f0">Eigen::sqrt</a></div><div class="ttdeci">const Eigen::CwiseUnaryOp&lt; Eigen::internal::scalar_sqrt_op&lt; typename Derived::Scalar &gt;, const Derived &gt; sqrt(const Eigen::ArrayBase&lt; Derived &gt; &amp;x)</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">The matrix A is:
 0.707107 -0.707107         0
 0.707107  0.707107         0
        0         0         1

The matrix logarithm of A is:
-8.86512e-17    -0.785398            0
    0.785398 -8.86512e-17            0
           0            0            0
</pre><dl class="section note"><dt>Note</dt><dd><code>M</code> has to be a matrix of <code>float</code>, <code>double</code>, <code>long double</code>, <code>complex&lt;float&gt;</code>, <code>complex&lt;double&gt;</code>, or <code>complex&lt;long double&gt;</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>MatrixBase::exp(), MatrixBase::matrixFunction(), class MatrixLogarithmAtomic, MatrixBase::sqrt().</dd></dl>
<h2><a class="anchor" id="matrixbase_pow"></a>
MatrixBase::pow()</h2>
<p>Compute the matrix raised to arbitrary real power.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixPowerReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::pow(RealScalar p) <span class="keyword">const</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>base of the matrix power, should be a square matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>exponent of the matrix power.</td></tr>
  </table>
  </dd>
</dl>
<p>The matrix power \( M^p \) is defined as \( \exp(p \log(M)) \), where exp denotes the matrix exponential, and log denotes the matrix logarithm. This is different from raising all the entries in the matrix to the p-th power. Use ArrayBase::pow() if you want to do the latter.</p>
<p>If <code>p</code> is complex, the scalar type of <code>M</code> should be the type of <code>p</code> . \( M^p \) simply evaluates into \( \exp(p \log(M)) \). Therefore, the matrix \( M \) should meet the conditions to be an argument of matrix logarithm.</p>
<p>If <code>p</code> is real, it is casted into the real scalar type of <code>M</code>. Then this function computes the matrix power using the Schur-Pad&eacute; algorithm as implemented by class MatrixPower. The exponent is split into integral part and fractional part, where the fractional part is in the interval \( (-1, 1) \). The main diagonal and the first super-diagonal is directly computed.</p>
<p>If <code>M</code> is singular with a semisimple zero eigenvalue and <code>p</code> is positive, the Schur factor \( T \) is reordered with Givens rotations, i.e.</p>
<p class="formulaDsp">
\[ T = \left[ \begin{array}{cc} T_1 &amp; T_2 \\ 0 &amp; 0 \end{array} \right] \]
</p>
<p>where \( T_1 \) is invertible. Then \( T^p \) is given by</p>
<p class="formulaDsp">
\[ T^p = \left[ \begin{array}{cc} T_1^p &amp; T_1^{-1} T_1^p T_2 \\ 0 &amp; 0 \end{array}. \right] \]
</p>
<dl class="section warning"><dt>Warning</dt><dd>Fractional power of a matrix with a non-semisimple zero eigenvalue is not well-defined. We introduce an assertion failure against inaccurate result, e.g.<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Eigen::Matrix4d A;</div>
<div class="line">  A &lt;&lt; 0, 0, 2, 3,</div>
<div class="line">       0, 0, 4, 5,</div>
<div class="line">       0, 0, 6, 7,</div>
<div class="line">       0, 0, 8, 9;</div>
<div class="line">  std::cout &lt;&lt; A.pow(0.37) &lt;&lt; std::endl;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The 1 makes eigenvalue 0 non-semisimple.</span></div>
<div class="line">  A.coeffRef(0, 1) = 1;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This fails if EIGEN_NO_DEBUG is undefined.</span></div>
<div class="line">  std::cout &lt;&lt; A.pow(0.37) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<p>Details of the algorithm can be found in: Nicholas J. Higham and Lijing Lin, "A Schur-Pad&amp;eacute; algorithm for fractional powers of a
matrix," <em>SIAM J. Matrix Anal. Applic.</em>, <b>32(3)</b>:1056&ndash;1078, 2011.</p>
<p>Example: The following program checks that </p><p class="formulaDsp">
\[ \left[ \begin{array}{ccc} \cos1 &amp; -\sin1 &amp; 0 \\ \sin1 &amp; \cos1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right]^{\frac14\pi} = \left[ \begin{array}{ccc} \frac12\sqrt2 &amp; -\frac12\sqrt2 &amp; 0 \\ \frac12\sqrt2 &amp; \frac12\sqrt2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right]. \]
</p>
<p> This corresponds to \( \frac14\pi \) rotations of 1 radian around the z-axis.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pi = std::acos(-1.0);</div>
<div class="line">  Matrix3d A;</div>
<div class="line">  A &lt;&lt; <a class="codeRef" href="../namespaceEigen.html#ad01d50a42869218f1d54af13f71517a6">cos</a>(1), -<a class="codeRef" href="../namespaceEigen.html#ae6e8ad270ff41c088d7651567594f796">sin</a>(1), 0,</div>
<div class="line">       <a class="codeRef" href="../namespaceEigen.html#ae6e8ad270ff41c088d7651567594f796">sin</a>(1),  <a class="codeRef" href="../namespaceEigen.html#ad01d50a42869218f1d54af13f71517a6">cos</a>(1), 0,</div>
<div class="line">           0 ,      0 , 1;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix A is:\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;The matrix power A^(pi/4) is:\n&quot;</span> &lt;&lt; A.pow(pi/4) &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceEigen_html_ad01d50a42869218f1d54af13f71517a6"><div class="ttname"><a href="../namespaceEigen.html#ad01d50a42869218f1d54af13f71517a6">Eigen::cos</a></div><div class="ttdeci">const Eigen::CwiseUnaryOp&lt; Eigen::internal::scalar_cos_op&lt; typename Derived::Scalar &gt;, const Derived &gt; cos(const Eigen::ArrayBase&lt; Derived &gt; &amp;x)</div></div>
<div class="ttc" id="anamespaceEigen_html_ae6e8ad270ff41c088d7651567594f796"><div class="ttname"><a href="../namespaceEigen.html#ae6e8ad270ff41c088d7651567594f796">Eigen::sin</a></div><div class="ttdeci">const Eigen::CwiseUnaryOp&lt; Eigen::internal::scalar_sin_op&lt; typename Derived::Scalar &gt;, const Derived &gt; sin(const Eigen::ArrayBase&lt; Derived &gt; &amp;x)</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">The matrix A is:
 0.540302 -0.841471         0
 0.841471  0.540302         0
        0         0         1

The matrix power A^(pi/4) is:
 0.707107 -0.707107         0
 0.707107  0.707107         0
        0         0         1
</pre><p>MatrixBase::pow() is user-friendly. However, there are some circumstances under which you should use class MatrixPower directly. MatrixPower can save the result of Schur decomposition, so it's better for computing various powers for the same matrix.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Matrix4cd A = Matrix4cd::Random();</div>
<div class="line">  MatrixPower&lt;Matrix4cd&gt; Apow(A);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix A is:\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;A^3.1 is:\n&quot;</span> &lt;&lt; Apow(3.1) &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;A^3.3 is:\n&quot;</span> &lt;&lt; Apow(3.3) &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;A^3.7 is:\n&quot;</span> &lt;&lt; Apow(3.7) &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;A^3.9 is:\n&quot;</span> &lt;&lt; Apow(3.9) &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">The matrix A is:
 (-0.211234,0.680375)   (0.10794,-0.444451)   (0.434594,0.271423) (-0.198111,-0.686642)
   (0.59688,0.566198) (0.257742,-0.0452059)  (0.213938,-0.716795) (-0.782382,-0.740419)
 (-0.604897,0.823295) (0.0268018,-0.270431) (-0.514226,-0.967399)  (-0.563486,0.997849)
 (0.536459,-0.329554)    (0.83239,0.904459)  (0.608354,-0.725537)  (0.678224,0.0258648)

A^3.1 is:
   (2.80575,-0.607662) (-1.16847,-0.00660555)    (-0.760385,1.01461)   (-0.38073,-0.106512)
     (1.4041,-3.61891)     (1.00481,0.186263)   (-0.163888,0.449419)   (-0.388981,-1.22629)
   (-2.07957,-1.58136)     (0.825866,2.25962)     (5.09383,0.155736)    (0.394308,-1.63034)
  (-0.818997,0.671026)  (2.11069,-0.00768024)    (-1.37876,0.140165)    (2.50512,-0.854429)

A^3.3 is:
  (2.83571,-0.238717) (-1.48174,-0.0615217)  (-0.0544396,1.68092) (-0.292699,-0.621726)
    (2.0521,-3.58316)    (0.87894,0.400548)  (0.738072,-0.121242)   (-1.07957,-1.63492)
  (-3.00106,-1.10558)     (1.52205,1.92407)    (5.29759,-1.83562)  (-0.532038,-1.50253)
  (-0.491353,-0.4145)     (2.5761,0.481286)  (-1.21994,0.0367069)    (2.67112,-1.06331)

A^3.7 is:
     (1.42126,0.33362)   (-1.39486,-0.560486)      (1.44968,2.47066)   (-0.324079,-1.75879)
    (2.65301,-1.82427)   (0.357333,-0.192429)      (2.01017,-1.4791)    (-2.71518,-2.35892)
   (-3.98544,0.964861)     (2.26033,0.554254)     (3.18211,-5.94352)    (-2.22888,0.128951)
   (0.944969,-2.14683)      (3.31345,1.66075) (-0.0623743,-0.848324)        (2.3897,-1.863)

A^3.9 is:
 (0.0720766,0.378685) (-0.931961,-0.978624)      (1.9855,2.34105)  (-0.530547,-2.17664)
  (2.40934,-0.265286)  (0.0299975,-1.08827)    (1.98974,-2.05886)   (-3.45767,-2.50235)
    (-3.71666,2.3874)        (2.054,-0.303)   (0.844348,-7.29588)    (-2.59136,1.57689)
   (1.87645,-2.38798)     (3.52111,2.10508)    (0.799055,-1.6122)    (1.93452,-2.44408)
</pre><dl class="section note"><dt>Note</dt><dd><code>M</code> has to be a matrix of <code>float</code>, <code>double</code>, <code>long double</code>, <code>complex&lt;float&gt;</code>, <code>complex&lt;double&gt;</code>, or <code>complex&lt;long double&gt;</code> .</dd></dl>
<dl class="section see"><dt>See also</dt><dd>MatrixBase::exp(), MatrixBase::log(), class MatrixPower.</dd></dl>
<h2><a class="anchor" id="matrixbase_matrixfunction"></a>
MatrixBase::matrixFunction()</h2>
<p>Compute a matrix function.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::matrixFunction(<span class="keyword">typename</span> internal::stem_function&lt;<span class="keyword">typename</span> internal::traits&lt;Derived&gt;::Scalar&gt;::type f) <span class="keyword">const</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>argument of matrix function, should be a square matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>an entire function; <code>f(x,n)</code> should compute the n-th derivative of f at x. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing <code>f</code> applied to <code>M</code>.</dd></dl>
<p>Suppose that <code>M</code> is a matrix whose entries have type <code>Scalar</code>. Then, the second argument, <code>f</code>, should be a function with prototype </p><div class="fragment"><div class="line">ComplexScalar f(ComplexScalar, <span class="keywordtype">int</span>) </div>
</div><!-- fragment --><p> where <code>ComplexScalar</code> = <code>std::complex&lt;Scalar&gt;</code> if <code>Scalar</code> is real (e.g., <code>float</code> or <code>double</code>) and <code>ComplexScalar</code> = <code>Scalar</code> if <code>Scalar</code> is complex. The return value of <code>f(x,n)</code> should be \( f^{(n)}(x) \), the n-th derivative of f at x.</p>
<p>This routine uses the algorithm described in: Philip Davies and Nicholas J. Higham, "A Schur-Parlett algorithm for computing matrix functions", <em>SIAM J. Matrix Anal. Applic.</em>, <b>25</b>:464&ndash;485, 2003.</p>
<p>The actual work is done by the MatrixFunction class.</p>
<p>Example: The following program checks that </p><p class="formulaDsp">
\[ \exp \left[ \begin{array}{ccc} 0 &amp; \frac14\pi &amp; 0 \\ -\frac14\pi &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \end{array} \right] = \left[ \begin{array}{ccc} \frac12\sqrt2 &amp; -\frac12\sqrt2 &amp; 0 \\ \frac12\sqrt2 &amp; \frac12\sqrt2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right]. \]
</p>
<p> This corresponds to a rotation of \( \frac14\pi \) radians around the z-axis. This is the same example as used in the documentation of <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_exp">exp()</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line">std::complex&lt;double&gt; expfn(std::complex&lt;double&gt; x, <span class="keywordtype">int</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> std::exp(x);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pi = std::acos(-1.0);</div>
<div class="line"> </div>
<div class="line">  MatrixXd A(3,3);</div>
<div class="line">  A &lt;&lt; 0,    -pi/4, 0,</div>
<div class="line">       pi/4, 0,     0,</div>
<div class="line">       0,    0,     0;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix A is:\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix exponential of A is:\n&quot;</span> </div>
<div class="line">            &lt;&lt; A.matrixFunction(expfn) &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">The matrix A is:
        0 -0.785398         0
 0.785398         0         0
        0         0         0

The matrix exponential of A is:
 0.707107 -0.707107         0
 0.707107  0.707107         0
        0         0         1

</pre><p>Note that the function <code>expfn</code> is defined for complex numbers <code>x</code>, even though the matrix <code>A</code> is over the reals. Instead of <code>expfn</code>, we could also have used StdStemFunctions::exp: </p><div class="fragment"><div class="line">A.matrixFunction(StdStemFunctions&lt;std::complex&lt;double&gt; &gt;::exp, &amp;B);</div>
</div><!-- fragment --><h2><a class="anchor" id="matrixbase_sin"></a>
MatrixBase::sin()</h2>
<p>Compute the matrix sine.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::sin() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>a square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing \( \sin(M) \).</dd></dl>
<p>This function computes the matrix sine. Use ArrayBase::sin() for computing the entry-wise sine.</p>
<p>The implementation calls <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::sin().</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  MatrixXd A = MatrixXd::Random(3,3);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;A = \n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  MatrixXd sinA = A.sin();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;sin(A) = \n&quot;</span> &lt;&lt; sinA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  MatrixXd cosA = A.cos();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;cos(A) = \n&quot;</span> &lt;&lt; cosA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The matrix functions satisfy sin^2(A) + cos^2(A) = I, </span></div>
<div class="line">  <span class="comment">// like the scalar functions.</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;sin^2(A) + cos^2(A) = \n&quot;</span> &lt;&lt; sinA*sinA + cosA*cosA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">A = 
 0.680375   0.59688 -0.329554
-0.211234  0.823295  0.536459
 0.566198 -0.604897 -0.444451

sin(A) = 
 0.679919    0.4579 -0.400612
-0.227278  0.821913    0.5358
 0.570141 -0.676728 -0.462398

cos(A) = 
  0.927728  -0.530361  -0.110482
0.00969246   0.889022  -0.137604
 -0.132574   -0.04289    1.16475

sin^2(A) + cos^2(A) = 
           1 -7.77156e-16  4.71845e-16
-5.55112e-17            1  2.77556e-16
 1.66533e-16 -2.08167e-16            1

</pre><h2><a class="anchor" id="matrixbase_sinh"></a>
MatrixBase::sinh()</h2>
<p>Compute the matrix hyperbolic sine.</p>
<div class="fragment"><div class="line">MatrixFunctionReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::sinh() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>a square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing \( \sinh(M) \)</dd></dl>
<p>This function calls <a class="el" href="group__MatrixFunctions__Module.html#matrixbase_matrixfunction">matrixFunction()</a> with StdStemFunctions::sinh().</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  MatrixXf A = MatrixXf::Random(3,3);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;A = \n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  MatrixXf sinhA = A.sinh();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;sinh(A) = \n&quot;</span> &lt;&lt; sinhA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  MatrixXf coshA = A.cosh();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;cosh(A) = \n&quot;</span> &lt;&lt; coshA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The matrix functions satisfy cosh^2(A) - sinh^2(A) = I, </span></div>
<div class="line">  <span class="comment">// like the scalar functions.</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;cosh^2(A) - sinh^2(A) = \n&quot;</span> &lt;&lt; coshA*coshA - sinhA*sinhA &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">A = 
 0.680375   0.59688 -0.329554
-0.211234  0.823295  0.536459
 0.566198 -0.604897 -0.444451

sinh(A) = 
 0.682534  0.739988 -0.256871
-0.194928  0.826512  0.537546
 0.562584  -0.53163 -0.425199

cosh(A) = 
  1.07817  0.567068  0.132125
-0.004186   1.11649  0.135361
 0.128891  0.065999  0.851201

cosh^2(A) - sinh^2(A) = 
          1 1.19209e-07           0
2.10479e-07           1 1.78814e-07
1.19209e-07 2.38419e-07           1

</pre><h2><a class="anchor" id="matrixbase_sqrt"></a>
MatrixBase::sqrt()</h2>
<p>Compute the matrix square root.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MatrixSquareRootReturnValue&lt;Derived&gt; MatrixBase&lt;Derived&gt;::sqrt() const</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>invertible matrix whose square root is to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression representing the matrix square root of <code>M</code>.</dd></dl>
<p>The matrix square root of \( M \) is the matrix \( M^{1/2} \) whose square is the original matrix; so if \( S = M^{1/2} \) then \( S^2 = M \). This is different from taking the square root of all the entries in the matrix; use ArrayBase::sqrt() if you want to do the latter.</p>
<p>In the <b>real case</b>, the matrix \( M \) should be invertible and it should have no eigenvalues which are real and negative (pairs of complex conjugate eigenvalues are allowed). In that case, the matrix has a square root which is also real, and this is the square root computed by this function.</p>
<p>The matrix square root is computed by first reducing the matrix to quasi-triangular form with the real Schur decomposition. The square root of the quasi-triangular matrix can then be computed directly. The cost is approximately \( 25 n^3 \) real flops for the real Schur decomposition and \( 3\frac13 n^3 \) real flops for the remainder (though the computation time in practice is likely more than this indicates).</p>
<p>Details of the algorithm can be found in: Nicholas J. Highan, "Computing real square roots of a real matrix", <em>Linear Algebra Appl.</em>, 88/89:405&ndash;430, 1987.</p>
<p>If the matrix is <b>positive-definite symmetric</b>, then the square root is also positive-definite symmetric. In this case, it is best to use SelfAdjointEigenSolver::operatorSqrt() to compute it.</p>
<p>In the <b>complex case</b>, the matrix \( M \) should be invertible; this is a restriction of the algorithm. The square root computed by this algorithm is the one whose eigenvalues have an argument in the interval \( (-\frac12\pi, \frac12\pi] \). This is the usual branch cut.</p>
<p>The computation is the same as in the real case, except that the complex Schur decomposition is used to reduce the matrix to a triangular matrix. The theoretical cost is the same. Details are in: &Aring;ke Bj&ouml;rck and Sven Hammarling, "A Schur method for the
square root of a matrix", <em>Linear Algebra Appl.</em>, 52/53:127&ndash;140, 1983.</p>
<p>Example: The following program checks that the square root of </p><p class="formulaDsp">
\[ \left[ \begin{array}{cc} \cos(\frac13\pi) &amp; -\sin(\frac13\pi) \\ \sin(\frac13\pi) &amp; \cos(\frac13\pi) \end{array} \right], \]
</p>
<p> corresponding to a rotation over 60 degrees, is a rotation over 30 degrees: </p><p class="formulaDsp">
\[ \left[ \begin{array}{cc} \cos(\frac16\pi) &amp; -\sin(\frac16\pi) \\ \sin(\frac16\pi) &amp; \cos(\frac16\pi) \end{array} \right]. \]
</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unsupported/Eigen/MatrixFunctions&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pi = std::acos(-1.0);</div>
<div class="line"> </div>
<div class="line">  MatrixXd A(2,2);</div>
<div class="line">  A &lt;&lt; <a class="codeRef" href="../namespaceEigen.html#ad01d50a42869218f1d54af13f71517a6">cos</a>(pi/3), -<a class="codeRef" href="../namespaceEigen.html#ae6e8ad270ff41c088d7651567594f796">sin</a>(pi/3), </div>
<div class="line">       <a class="codeRef" href="../namespaceEigen.html#ae6e8ad270ff41c088d7651567594f796">sin</a>(pi/3),  <a class="codeRef" href="../namespaceEigen.html#ad01d50a42869218f1d54af13f71517a6">cos</a>(pi/3);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix A is:\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The matrix square root of A is:\n&quot;</span> &lt;&lt; A.sqrt() &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The square of the last matrix is:\n&quot;</span> &lt;&lt; A.sqrt() * A.sqrt() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">The matrix A is:
      0.5 -0.866025
 0.866025       0.5

The matrix square root of A is:
0.866025     -0.5
     0.5 0.866025

The square of the last matrix is:
      0.5 -0.866025
 0.866025       0.5
</pre><dl class="section see"><dt>See also</dt><dd>class RealSchur, class ComplexSchur, class MatrixSquareRoot, SelfAdjointEigenSolver::operatorSqrt(). </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ga2f490197e16df831683018e383e29346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f490197e16df831683018e383e29346">&#9670;&nbsp;</a></span>matrix_sqrt_quasi_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::matrix_sqrt_quasi_triangular </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix square root of quasi-triangular matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>type of <code>arg</code>, the argument of matrix square root, expected to be an instantiation of the <a class="elRef" href="../classEigen_1_1Matrix.html">Matrix</a> class template. </td></tr>
    <tr><td class="paramname">ResultType</td><td>type of <code>result</code>, where result is to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of matrix square root. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>matrix square root of upper Hessenberg part of <code>arg</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the square root of the upper quasi-triangular matrix stored in the upper Hessenberg part of <code>arg</code>. Only the upper Hessenberg part of <code>result</code> is updated, the rest is not touched. See <a class="elRef" href="../classEigen_1_1MatrixBase.html#ad873dca860bd47baeeede8663e161b83">MatrixBase::sqrt()</a> for details on how this computation is implemented.</p>
<dl class="section see"><dt>See also</dt><dd>MatrixSquareRoot, MatrixSquareRootQuasiTriangular </dd></dl>

</div>
</div>
<a id="gae51c91f920f6ea4a7f6f72caa1e8249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae51c91f920f6ea4a7f6f72caa1e8249f">&#9670;&nbsp;</a></span>matrix_sqrt_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::matrix_sqrt_triangular </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix square root of triangular matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>type of <code>arg</code>, the argument of matrix square root, expected to be an instantiation of the <a class="elRef" href="../classEigen_1_1Matrix.html">Matrix</a> class template. </td></tr>
    <tr><td class="paramname">ResultType</td><td>type of <code>result</code>, where result is to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of matrix square root. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>matrix square root of upper triangular part of <code>arg</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Only the upper triangular part (including the diagonal) of <code>result</code> is updated, the rest is not touched. See <a class="elRef" href="../classEigen_1_1MatrixBase.html#ad873dca860bd47baeeede8663e161b83">MatrixBase::sqrt()</a> for details on how this computation is implemented.</p>
<dl class="section see"><dt>See also</dt><dd>MatrixSquareRoot, MatrixSquareRootQuasiTriangular </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 18 2021 14:57:26 for Eigen-unsupported by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
